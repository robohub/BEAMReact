// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  bizAttribute: (where?: BizAttributeWhereInput) => Promise<boolean>;
  bizRelation: (where?: BizRelationWhereInput) => Promise<boolean>;
  businessObject: (where?: BusinessObjectWhereInput) => Promise<boolean>;
  diagram: (where?: DiagramWhereInput) => Promise<boolean>;
  metaAttribute: (where?: MetaAttributeWhereInput) => Promise<boolean>;
  metaObject: (where?: MetaObjectWhereInput) => Promise<boolean>;
  metaRelation: (where?: MetaRelationWhereInput) => Promise<boolean>;
  plan: (where?: PlanWhereInput) => Promise<boolean>;
  planConfig: (where?: PlanConfigWhereInput) => Promise<boolean>;
  renderColumn: (where?: RenderColumnWhereInput) => Promise<boolean>;
  sMTransition: (where?: SMTransitionWhereInput) => Promise<boolean>;
  stateMachineSchema: (
    where?: StateMachineSchemaWhereInput
  ) => Promise<boolean>;
  systemSetup: (where?: SystemSetupWhereInput) => Promise<boolean>;
  template: (where?: TemplateWhereInput) => Promise<boolean>;
  templateConfig: (where?: TemplateConfigWhereInput) => Promise<boolean>;
  templateMapping: (where?: TemplateMappingWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  widget: (where?: WidgetWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bizAttribute: (where: BizAttributeWhereUniqueInput) => BizAttributePromise;
  bizAttributes: (args?: {
    where?: BizAttributeWhereInput;
    orderBy?: BizAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BizAttribute>;
  bizAttributesConnection: (args?: {
    where?: BizAttributeWhereInput;
    orderBy?: BizAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BizAttributeConnectionPromise;
  bizRelation: (where: BizRelationWhereUniqueInput) => BizRelationPromise;
  bizRelations: (args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BizRelation>;
  bizRelationsConnection: (args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BizRelationConnectionPromise;
  businessObject: (
    where: BusinessObjectWhereUniqueInput
  ) => BusinessObjectPromise;
  businessObjects: (args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BusinessObject>;
  businessObjectsConnection: (args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BusinessObjectConnectionPromise;
  diagram: (where: DiagramWhereUniqueInput) => DiagramPromise;
  diagrams: (args?: {
    where?: DiagramWhereInput;
    orderBy?: DiagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Diagram>;
  diagramsConnection: (args?: {
    where?: DiagramWhereInput;
    orderBy?: DiagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DiagramConnectionPromise;
  metaAttribute: (where: MetaAttributeWhereUniqueInput) => MetaAttributePromise;
  metaAttributes: (args?: {
    where?: MetaAttributeWhereInput;
    orderBy?: MetaAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MetaAttribute>;
  metaAttributesConnection: (args?: {
    where?: MetaAttributeWhereInput;
    orderBy?: MetaAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MetaAttributeConnectionPromise;
  metaObject: (where: MetaObjectWhereUniqueInput) => MetaObjectPromise;
  metaObjects: (args?: {
    where?: MetaObjectWhereInput;
    orderBy?: MetaObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MetaObject>;
  metaObjectsConnection: (args?: {
    where?: MetaObjectWhereInput;
    orderBy?: MetaObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MetaObjectConnectionPromise;
  metaRelation: (where: MetaRelationWhereUniqueInput) => MetaRelationPromise;
  metaRelations: (args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MetaRelation>;
  metaRelationsConnection: (args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MetaRelationConnectionPromise;
  plan: (where: PlanWhereUniqueInput) => PlanPromise;
  plans: (args?: {
    where?: PlanWhereInput;
    orderBy?: PlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Plan>;
  plansConnection: (args?: {
    where?: PlanWhereInput;
    orderBy?: PlanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlanConnectionPromise;
  planConfig: (where: PlanConfigWhereUniqueInput) => PlanConfigPromise;
  planConfigs: (args?: {
    where?: PlanConfigWhereInput;
    orderBy?: PlanConfigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlanConfig>;
  planConfigsConnection: (args?: {
    where?: PlanConfigWhereInput;
    orderBy?: PlanConfigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlanConfigConnectionPromise;
  renderColumn: (where: RenderColumnWhereUniqueInput) => RenderColumnPromise;
  renderColumns: (args?: {
    where?: RenderColumnWhereInput;
    orderBy?: RenderColumnOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RenderColumn>;
  renderColumnsConnection: (args?: {
    where?: RenderColumnWhereInput;
    orderBy?: RenderColumnOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RenderColumnConnectionPromise;
  sMTransition: (where: SMTransitionWhereUniqueInput) => SMTransitionPromise;
  sMTransitions: (args?: {
    where?: SMTransitionWhereInput;
    orderBy?: SMTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SMTransition>;
  sMTransitionsConnection: (args?: {
    where?: SMTransitionWhereInput;
    orderBy?: SMTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SMTransitionConnectionPromise;
  stateMachineSchema: (
    where: StateMachineSchemaWhereUniqueInput
  ) => StateMachineSchemaPromise;
  stateMachineSchemas: (args?: {
    where?: StateMachineSchemaWhereInput;
    orderBy?: StateMachineSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StateMachineSchema>;
  stateMachineSchemasConnection: (args?: {
    where?: StateMachineSchemaWhereInput;
    orderBy?: StateMachineSchemaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StateMachineSchemaConnectionPromise;
  systemSetup: (where: SystemSetupWhereUniqueInput) => SystemSetupPromise;
  systemSetups: (args?: {
    where?: SystemSetupWhereInput;
    orderBy?: SystemSetupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SystemSetup>;
  systemSetupsConnection: (args?: {
    where?: SystemSetupWhereInput;
    orderBy?: SystemSetupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SystemSetupConnectionPromise;
  template: (where: TemplateWhereUniqueInput) => TemplatePromise;
  templates: (args?: {
    where?: TemplateWhereInput;
    orderBy?: TemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Template>;
  templatesConnection: (args?: {
    where?: TemplateWhereInput;
    orderBy?: TemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TemplateConnectionPromise;
  templateConfig: (
    where: TemplateConfigWhereUniqueInput
  ) => TemplateConfigPromise;
  templateConfigs: (args?: {
    where?: TemplateConfigWhereInput;
    orderBy?: TemplateConfigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TemplateConfig>;
  templateConfigsConnection: (args?: {
    where?: TemplateConfigWhereInput;
    orderBy?: TemplateConfigOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TemplateConfigConnectionPromise;
  templateMapping: (
    where: TemplateMappingWhereUniqueInput
  ) => TemplateMappingPromise;
  templateMappings: (args?: {
    where?: TemplateMappingWhereInput;
    orderBy?: TemplateMappingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TemplateMapping>;
  templateMappingsConnection: (args?: {
    where?: TemplateMappingWhereInput;
    orderBy?: TemplateMappingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TemplateMappingConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  widget: (where: WidgetWhereUniqueInput) => WidgetPromise;
  widgets: (args?: {
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Widget>;
  widgetsConnection: (args?: {
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WidgetConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBizAttribute: (data: BizAttributeCreateInput) => BizAttributePromise;
  updateBizAttribute: (args: {
    data: BizAttributeUpdateInput;
    where: BizAttributeWhereUniqueInput;
  }) => BizAttributePromise;
  updateManyBizAttributes: (args: {
    data: BizAttributeUpdateManyMutationInput;
    where?: BizAttributeWhereInput;
  }) => BatchPayloadPromise;
  upsertBizAttribute: (args: {
    where: BizAttributeWhereUniqueInput;
    create: BizAttributeCreateInput;
    update: BizAttributeUpdateInput;
  }) => BizAttributePromise;
  deleteBizAttribute: (
    where: BizAttributeWhereUniqueInput
  ) => BizAttributePromise;
  deleteManyBizAttributes: (
    where?: BizAttributeWhereInput
  ) => BatchPayloadPromise;
  createBizRelation: (data: BizRelationCreateInput) => BizRelationPromise;
  updateBizRelation: (args: {
    data: BizRelationUpdateInput;
    where: BizRelationWhereUniqueInput;
  }) => BizRelationPromise;
  upsertBizRelation: (args: {
    where: BizRelationWhereUniqueInput;
    create: BizRelationCreateInput;
    update: BizRelationUpdateInput;
  }) => BizRelationPromise;
  deleteBizRelation: (where: BizRelationWhereUniqueInput) => BizRelationPromise;
  deleteManyBizRelations: (
    where?: BizRelationWhereInput
  ) => BatchPayloadPromise;
  createBusinessObject: (
    data: BusinessObjectCreateInput
  ) => BusinessObjectPromise;
  updateBusinessObject: (args: {
    data: BusinessObjectUpdateInput;
    where: BusinessObjectWhereUniqueInput;
  }) => BusinessObjectPromise;
  updateManyBusinessObjects: (args: {
    data: BusinessObjectUpdateManyMutationInput;
    where?: BusinessObjectWhereInput;
  }) => BatchPayloadPromise;
  upsertBusinessObject: (args: {
    where: BusinessObjectWhereUniqueInput;
    create: BusinessObjectCreateInput;
    update: BusinessObjectUpdateInput;
  }) => BusinessObjectPromise;
  deleteBusinessObject: (
    where: BusinessObjectWhereUniqueInput
  ) => BusinessObjectPromise;
  deleteManyBusinessObjects: (
    where?: BusinessObjectWhereInput
  ) => BatchPayloadPromise;
  createDiagram: (data: DiagramCreateInput) => DiagramPromise;
  updateDiagram: (args: {
    data: DiagramUpdateInput;
    where: DiagramWhereUniqueInput;
  }) => DiagramPromise;
  updateManyDiagrams: (args: {
    data: DiagramUpdateManyMutationInput;
    where?: DiagramWhereInput;
  }) => BatchPayloadPromise;
  upsertDiagram: (args: {
    where: DiagramWhereUniqueInput;
    create: DiagramCreateInput;
    update: DiagramUpdateInput;
  }) => DiagramPromise;
  deleteDiagram: (where: DiagramWhereUniqueInput) => DiagramPromise;
  deleteManyDiagrams: (where?: DiagramWhereInput) => BatchPayloadPromise;
  createMetaAttribute: (data: MetaAttributeCreateInput) => MetaAttributePromise;
  updateMetaAttribute: (args: {
    data: MetaAttributeUpdateInput;
    where: MetaAttributeWhereUniqueInput;
  }) => MetaAttributePromise;
  updateManyMetaAttributes: (args: {
    data: MetaAttributeUpdateManyMutationInput;
    where?: MetaAttributeWhereInput;
  }) => BatchPayloadPromise;
  upsertMetaAttribute: (args: {
    where: MetaAttributeWhereUniqueInput;
    create: MetaAttributeCreateInput;
    update: MetaAttributeUpdateInput;
  }) => MetaAttributePromise;
  deleteMetaAttribute: (
    where: MetaAttributeWhereUniqueInput
  ) => MetaAttributePromise;
  deleteManyMetaAttributes: (
    where?: MetaAttributeWhereInput
  ) => BatchPayloadPromise;
  createMetaObject: (data: MetaObjectCreateInput) => MetaObjectPromise;
  updateMetaObject: (args: {
    data: MetaObjectUpdateInput;
    where: MetaObjectWhereUniqueInput;
  }) => MetaObjectPromise;
  updateManyMetaObjects: (args: {
    data: MetaObjectUpdateManyMutationInput;
    where?: MetaObjectWhereInput;
  }) => BatchPayloadPromise;
  upsertMetaObject: (args: {
    where: MetaObjectWhereUniqueInput;
    create: MetaObjectCreateInput;
    update: MetaObjectUpdateInput;
  }) => MetaObjectPromise;
  deleteMetaObject: (where: MetaObjectWhereUniqueInput) => MetaObjectPromise;
  deleteManyMetaObjects: (where?: MetaObjectWhereInput) => BatchPayloadPromise;
  createMetaRelation: (data: MetaRelationCreateInput) => MetaRelationPromise;
  updateMetaRelation: (args: {
    data: MetaRelationUpdateInput;
    where: MetaRelationWhereUniqueInput;
  }) => MetaRelationPromise;
  updateManyMetaRelations: (args: {
    data: MetaRelationUpdateManyMutationInput;
    where?: MetaRelationWhereInput;
  }) => BatchPayloadPromise;
  upsertMetaRelation: (args: {
    where: MetaRelationWhereUniqueInput;
    create: MetaRelationCreateInput;
    update: MetaRelationUpdateInput;
  }) => MetaRelationPromise;
  deleteMetaRelation: (
    where: MetaRelationWhereUniqueInput
  ) => MetaRelationPromise;
  deleteManyMetaRelations: (
    where?: MetaRelationWhereInput
  ) => BatchPayloadPromise;
  createPlan: (data: PlanCreateInput) => PlanPromise;
  updatePlan: (args: {
    data: PlanUpdateInput;
    where: PlanWhereUniqueInput;
  }) => PlanPromise;
  updateManyPlans: (args: {
    data: PlanUpdateManyMutationInput;
    where?: PlanWhereInput;
  }) => BatchPayloadPromise;
  upsertPlan: (args: {
    where: PlanWhereUniqueInput;
    create: PlanCreateInput;
    update: PlanUpdateInput;
  }) => PlanPromise;
  deletePlan: (where: PlanWhereUniqueInput) => PlanPromise;
  deleteManyPlans: (where?: PlanWhereInput) => BatchPayloadPromise;
  createPlanConfig: (data: PlanConfigCreateInput) => PlanConfigPromise;
  updatePlanConfig: (args: {
    data: PlanConfigUpdateInput;
    where: PlanConfigWhereUniqueInput;
  }) => PlanConfigPromise;
  upsertPlanConfig: (args: {
    where: PlanConfigWhereUniqueInput;
    create: PlanConfigCreateInput;
    update: PlanConfigUpdateInput;
  }) => PlanConfigPromise;
  deletePlanConfig: (where: PlanConfigWhereUniqueInput) => PlanConfigPromise;
  deleteManyPlanConfigs: (where?: PlanConfigWhereInput) => BatchPayloadPromise;
  createRenderColumn: (data: RenderColumnCreateInput) => RenderColumnPromise;
  updateRenderColumn: (args: {
    data: RenderColumnUpdateInput;
    where: RenderColumnWhereUniqueInput;
  }) => RenderColumnPromise;
  updateManyRenderColumns: (args: {
    data: RenderColumnUpdateManyMutationInput;
    where?: RenderColumnWhereInput;
  }) => BatchPayloadPromise;
  upsertRenderColumn: (args: {
    where: RenderColumnWhereUniqueInput;
    create: RenderColumnCreateInput;
    update: RenderColumnUpdateInput;
  }) => RenderColumnPromise;
  deleteRenderColumn: (
    where: RenderColumnWhereUniqueInput
  ) => RenderColumnPromise;
  deleteManyRenderColumns: (
    where?: RenderColumnWhereInput
  ) => BatchPayloadPromise;
  createSMTransition: (data: SMTransitionCreateInput) => SMTransitionPromise;
  updateSMTransition: (args: {
    data: SMTransitionUpdateInput;
    where: SMTransitionWhereUniqueInput;
  }) => SMTransitionPromise;
  updateManySMTransitions: (args: {
    data: SMTransitionUpdateManyMutationInput;
    where?: SMTransitionWhereInput;
  }) => BatchPayloadPromise;
  upsertSMTransition: (args: {
    where: SMTransitionWhereUniqueInput;
    create: SMTransitionCreateInput;
    update: SMTransitionUpdateInput;
  }) => SMTransitionPromise;
  deleteSMTransition: (
    where: SMTransitionWhereUniqueInput
  ) => SMTransitionPromise;
  deleteManySMTransitions: (
    where?: SMTransitionWhereInput
  ) => BatchPayloadPromise;
  createStateMachineSchema: (
    data: StateMachineSchemaCreateInput
  ) => StateMachineSchemaPromise;
  updateStateMachineSchema: (args: {
    data: StateMachineSchemaUpdateInput;
    where: StateMachineSchemaWhereUniqueInput;
  }) => StateMachineSchemaPromise;
  updateManyStateMachineSchemas: (args: {
    data: StateMachineSchemaUpdateManyMutationInput;
    where?: StateMachineSchemaWhereInput;
  }) => BatchPayloadPromise;
  upsertStateMachineSchema: (args: {
    where: StateMachineSchemaWhereUniqueInput;
    create: StateMachineSchemaCreateInput;
    update: StateMachineSchemaUpdateInput;
  }) => StateMachineSchemaPromise;
  deleteStateMachineSchema: (
    where: StateMachineSchemaWhereUniqueInput
  ) => StateMachineSchemaPromise;
  deleteManyStateMachineSchemas: (
    where?: StateMachineSchemaWhereInput
  ) => BatchPayloadPromise;
  createSystemSetup: (data: SystemSetupCreateInput) => SystemSetupPromise;
  updateSystemSetup: (args: {
    data: SystemSetupUpdateInput;
    where: SystemSetupWhereUniqueInput;
  }) => SystemSetupPromise;
  upsertSystemSetup: (args: {
    where: SystemSetupWhereUniqueInput;
    create: SystemSetupCreateInput;
    update: SystemSetupUpdateInput;
  }) => SystemSetupPromise;
  deleteSystemSetup: (where: SystemSetupWhereUniqueInput) => SystemSetupPromise;
  deleteManySystemSetups: (
    where?: SystemSetupWhereInput
  ) => BatchPayloadPromise;
  createTemplate: (data: TemplateCreateInput) => TemplatePromise;
  updateTemplate: (args: {
    data: TemplateUpdateInput;
    where: TemplateWhereUniqueInput;
  }) => TemplatePromise;
  updateManyTemplates: (args: {
    data: TemplateUpdateManyMutationInput;
    where?: TemplateWhereInput;
  }) => BatchPayloadPromise;
  upsertTemplate: (args: {
    where: TemplateWhereUniqueInput;
    create: TemplateCreateInput;
    update: TemplateUpdateInput;
  }) => TemplatePromise;
  deleteTemplate: (where: TemplateWhereUniqueInput) => TemplatePromise;
  deleteManyTemplates: (where?: TemplateWhereInput) => BatchPayloadPromise;
  createTemplateConfig: (
    data: TemplateConfigCreateInput
  ) => TemplateConfigPromise;
  updateTemplateConfig: (args: {
    data: TemplateConfigUpdateInput;
    where: TemplateConfigWhereUniqueInput;
  }) => TemplateConfigPromise;
  updateManyTemplateConfigs: (args: {
    data: TemplateConfigUpdateManyMutationInput;
    where?: TemplateConfigWhereInput;
  }) => BatchPayloadPromise;
  upsertTemplateConfig: (args: {
    where: TemplateConfigWhereUniqueInput;
    create: TemplateConfigCreateInput;
    update: TemplateConfigUpdateInput;
  }) => TemplateConfigPromise;
  deleteTemplateConfig: (
    where: TemplateConfigWhereUniqueInput
  ) => TemplateConfigPromise;
  deleteManyTemplateConfigs: (
    where?: TemplateConfigWhereInput
  ) => BatchPayloadPromise;
  createTemplateMapping: (
    data: TemplateMappingCreateInput
  ) => TemplateMappingPromise;
  updateTemplateMapping: (args: {
    data: TemplateMappingUpdateInput;
    where: TemplateMappingWhereUniqueInput;
  }) => TemplateMappingPromise;
  upsertTemplateMapping: (args: {
    where: TemplateMappingWhereUniqueInput;
    create: TemplateMappingCreateInput;
    update: TemplateMappingUpdateInput;
  }) => TemplateMappingPromise;
  deleteTemplateMapping: (
    where: TemplateMappingWhereUniqueInput
  ) => TemplateMappingPromise;
  deleteManyTemplateMappings: (
    where?: TemplateMappingWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWidget: (data: WidgetCreateInput) => WidgetPromise;
  updateWidget: (args: {
    data: WidgetUpdateInput;
    where: WidgetWhereUniqueInput;
  }) => WidgetPromise;
  updateManyWidgets: (args: {
    data: WidgetUpdateManyMutationInput;
    where?: WidgetWhereInput;
  }) => BatchPayloadPromise;
  upsertWidget: (args: {
    where: WidgetWhereUniqueInput;
    create: WidgetCreateInput;
    update: WidgetUpdateInput;
  }) => WidgetPromise;
  deleteWidget: (where: WidgetWhereUniqueInput) => WidgetPromise;
  deleteManyWidgets: (where?: WidgetWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bizAttribute: (
    where?: BizAttributeSubscriptionWhereInput
  ) => BizAttributeSubscriptionPayloadSubscription;
  bizRelation: (
    where?: BizRelationSubscriptionWhereInput
  ) => BizRelationSubscriptionPayloadSubscription;
  businessObject: (
    where?: BusinessObjectSubscriptionWhereInput
  ) => BusinessObjectSubscriptionPayloadSubscription;
  diagram: (
    where?: DiagramSubscriptionWhereInput
  ) => DiagramSubscriptionPayloadSubscription;
  metaAttribute: (
    where?: MetaAttributeSubscriptionWhereInput
  ) => MetaAttributeSubscriptionPayloadSubscription;
  metaObject: (
    where?: MetaObjectSubscriptionWhereInput
  ) => MetaObjectSubscriptionPayloadSubscription;
  metaRelation: (
    where?: MetaRelationSubscriptionWhereInput
  ) => MetaRelationSubscriptionPayloadSubscription;
  plan: (
    where?: PlanSubscriptionWhereInput
  ) => PlanSubscriptionPayloadSubscription;
  planConfig: (
    where?: PlanConfigSubscriptionWhereInput
  ) => PlanConfigSubscriptionPayloadSubscription;
  renderColumn: (
    where?: RenderColumnSubscriptionWhereInput
  ) => RenderColumnSubscriptionPayloadSubscription;
  sMTransition: (
    where?: SMTransitionSubscriptionWhereInput
  ) => SMTransitionSubscriptionPayloadSubscription;
  stateMachineSchema: (
    where?: StateMachineSchemaSubscriptionWhereInput
  ) => StateMachineSchemaSubscriptionPayloadSubscription;
  systemSetup: (
    where?: SystemSetupSubscriptionWhereInput
  ) => SystemSetupSubscriptionPayloadSubscription;
  template: (
    where?: TemplateSubscriptionWhereInput
  ) => TemplateSubscriptionPayloadSubscription;
  templateConfig: (
    where?: TemplateConfigSubscriptionWhereInput
  ) => TemplateConfigSubscriptionPayloadSubscription;
  templateMapping: (
    where?: TemplateMappingSubscriptionWhereInput
  ) => TemplateMappingSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  widget: (
    where?: WidgetSubscriptionWhereInput
  ) => WidgetSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AttributeType = "String" | "Int" | "Float" | "DateTime" | "Boolean";

export type BizAttributeOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type DiagramOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "diagramData_ASC"
  | "diagramData_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userid_ASC"
  | "userid_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WidgetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "width_ASC"
  | "width_DESC"
  | "boid_ASC"
  | "boid_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TemplateConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userRelatedMRId_ASC"
  | "userRelatedMRId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RenderColumnOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "width_ASC"
  | "width_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SystemSetupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MetaRelationOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "multiplicity_ASC"
  | "multiplicity_DESC"
  | "oppositeName_ASC"
  | "oppositeName_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SMTransitionOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "event_ASC"
  | "event_DESC"
  | "from_ASC"
  | "from_DESC"
  | "id_ASC"
  | "id_DESC"
  | "to_ASC"
  | "to_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BusinessObjectOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "state_ASC"
  | "state_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "planData_ASC"
  | "planData_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WidgetType =
  | "Text"
  | "Plan"
  | "HTML"
  | "Diagram"
  | "Navigation"
  | "Tree"
  | "Video";

export type TemplateMappingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BizRelationOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MetaAttributeOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MultiplicityType = "One" | "Many";

export type MetaObjectOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TemplateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PlanConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StateMachineSchemaOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "finalState_ASC"
  | "finalState_DESC"
  | "id_ASC"
  | "id_DESC"
  | "initialState_ASC"
  | "initialState_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface MetaRelationUpdateManyWithoutOppositeObjectInput {
  create?:
    | MetaRelationCreateWithoutOppositeObjectInput[]
    | MetaRelationCreateWithoutOppositeObjectInput;
  delete?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  connect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  set?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  disconnect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  update?:
    | MetaRelationUpdateWithWhereUniqueWithoutOppositeObjectInput[]
    | MetaRelationUpdateWithWhereUniqueWithoutOppositeObjectInput;
  upsert?:
    | MetaRelationUpsertWithWhereUniqueWithoutOppositeObjectInput[]
    | MetaRelationUpsertWithWhereUniqueWithoutOppositeObjectInput;
  deleteMany?: MetaRelationScalarWhereInput[] | MetaRelationScalarWhereInput;
  updateMany?:
    | MetaRelationUpdateManyWithWhereNestedInput[]
    | MetaRelationUpdateManyWithWhereNestedInput;
}

export type BizAttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaRelationUpdateWithoutIncomingObjectDataInput {
  bizRelations?: BizRelationUpdateManyWithoutMetaRelationInput;
  multiplicity?: MultiplicityType;
  oppositeName?: String;
  oppositeObject?: MetaObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationUpdateOneWithoutOppositeRelationInput;
}

export interface DiagramWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  ownerBO?: BusinessObjectWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  participatingBOs_every?: BusinessObjectWhereInput;
  participatingBOs_some?: BusinessObjectWhereInput;
  participatingBOs_none?: BusinessObjectWhereInput;
  AND?: DiagramWhereInput[] | DiagramWhereInput;
  OR?: DiagramWhereInput[] | DiagramWhereInput;
  NOT?: DiagramWhereInput[] | DiagramWhereInput;
}

export interface BusinessObjectCreateOneWithoutOwnsDiagramsInput {
  create?: BusinessObjectCreateWithoutOwnsDiagramsInput;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface MetaObjectCreateWithoutPlanConfigInput {
  attributes?: MetaAttributeCreateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectCreateManyWithoutMetaObjectInput;
  id?: ID_Input;
  incomingRelations?: MetaRelationCreateManyWithoutOppositeObjectInput;
  name: String;
  outgoingRelations?: MetaRelationCreateManyWithoutIncomingObjectInput;
  templateConfig?: TemplateConfigCreateOneWithoutMoObjectInput;
}

export interface BusinessObjectCreateWithoutOwnsDiagramsInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface MetaObjectUpdateOneWithoutIncomingRelationsInput {
  create?: MetaObjectCreateWithoutIncomingRelationsInput;
  update?: MetaObjectUpdateWithoutIncomingRelationsDataInput;
  upsert?: MetaObjectUpsertWithoutIncomingRelationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaObjectWhereUniqueInput;
}

export interface BizRelationCreateOneWithoutOppositeRelationInput {
  create?: BizRelationCreateWithoutOppositeRelationInput;
  connect?: BizRelationWhereUniqueInput;
}

export interface WidgetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WidgetWhereInput;
  AND?: WidgetSubscriptionWhereInput[] | WidgetSubscriptionWhereInput;
  OR?: WidgetSubscriptionWhereInput[] | WidgetSubscriptionWhereInput;
  NOT?: WidgetSubscriptionWhereInput[] | WidgetSubscriptionWhereInput;
}

export interface BizRelationCreateWithoutOppositeRelationInput {
  id?: ID_Input;
  incomingObject?: BusinessObjectCreateOneWithoutOutgoingRelationsInput;
  metaRelation?: MetaRelationCreateOneWithoutBizRelationsInput;
  oppositeObject?: BusinessObjectCreateOneWithoutIncomingRelationsInput;
}

export interface WidgetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  type?: WidgetType;
  type_not?: WidgetType;
  type_in?: WidgetType[] | WidgetType;
  type_not_in?: WidgetType[] | WidgetType;
  width?: Int;
  width_not?: Int;
  width_in?: Int[] | Int;
  width_not_in?: Int[] | Int;
  width_lt?: Int;
  width_lte?: Int;
  width_gt?: Int;
  width_gte?: Int;
  boid?: String;
  boid_not?: String;
  boid_in?: String[] | String;
  boid_not_in?: String[] | String;
  boid_lt?: String;
  boid_lte?: String;
  boid_gt?: String;
  boid_gte?: String;
  boid_contains?: String;
  boid_not_contains?: String;
  boid_starts_with?: String;
  boid_not_starts_with?: String;
  boid_ends_with?: String;
  boid_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: WidgetWhereInput[] | WidgetWhereInput;
  OR?: WidgetWhereInput[] | WidgetWhereInput;
  NOT?: WidgetWhereInput[] | WidgetWhereInput;
}

export interface BizAttributeUpdateInput {
  businessObject?: BusinessObjectUpdateOneWithoutBizAttributesInput;
  metaAttribute?: MetaAttributeUpdateOneWithoutBizAttributesInput;
  value?: String;
}

export interface TemplateMappingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TemplateMappingWhereInput;
  AND?:
    | TemplateMappingSubscriptionWhereInput[]
    | TemplateMappingSubscriptionWhereInput;
  OR?:
    | TemplateMappingSubscriptionWhereInput[]
    | TemplateMappingSubscriptionWhereInput;
  NOT?:
    | TemplateMappingSubscriptionWhereInput[]
    | TemplateMappingSubscriptionWhereInput;
}

export interface BusinessObjectUpdateOneWithoutBizAttributesInput {
  create?: BusinessObjectCreateWithoutBizAttributesInput;
  update?: BusinessObjectUpdateWithoutBizAttributesDataInput;
  upsert?: BusinessObjectUpsertWithoutBizAttributesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface TemplateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TemplateWhereInput;
  AND?: TemplateSubscriptionWhereInput[] | TemplateSubscriptionWhereInput;
  OR?: TemplateSubscriptionWhereInput[] | TemplateSubscriptionWhereInput;
  NOT?: TemplateSubscriptionWhereInput[] | TemplateSubscriptionWhereInput;
}

export interface BusinessObjectUpdateWithoutBizAttributesDataInput {
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export interface SystemSetupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SystemSetupWhereInput;
  AND?: SystemSetupSubscriptionWhereInput[] | SystemSetupSubscriptionWhereInput;
  OR?: SystemSetupSubscriptionWhereInput[] | SystemSetupSubscriptionWhereInput;
  NOT?: SystemSetupSubscriptionWhereInput[] | SystemSetupSubscriptionWhereInput;
}

export interface BizRelationUpdateManyWithoutOppositeObjectInput {
  create?:
    | BizRelationCreateWithoutOppositeObjectInput[]
    | BizRelationCreateWithoutOppositeObjectInput;
  delete?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  connect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  set?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  disconnect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  update?:
    | BizRelationUpdateWithWhereUniqueWithoutOppositeObjectInput[]
    | BizRelationUpdateWithWhereUniqueWithoutOppositeObjectInput;
  upsert?:
    | BizRelationUpsertWithWhereUniqueWithoutOppositeObjectInput[]
    | BizRelationUpsertWithWhereUniqueWithoutOppositeObjectInput;
  deleteMany?: BizRelationScalarWhereInput[] | BizRelationScalarWhereInput;
}

export interface StateMachineSchemaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StateMachineSchemaWhereInput;
  AND?:
    | StateMachineSchemaSubscriptionWhereInput[]
    | StateMachineSchemaSubscriptionWhereInput;
  OR?:
    | StateMachineSchemaSubscriptionWhereInput[]
    | StateMachineSchemaSubscriptionWhereInput;
  NOT?:
    | StateMachineSchemaSubscriptionWhereInput[]
    | StateMachineSchemaSubscriptionWhereInput;
}

export interface BizRelationUpdateWithWhereUniqueWithoutOppositeObjectInput {
  where: BizRelationWhereUniqueInput;
  data: BizRelationUpdateWithoutOppositeObjectDataInput;
}

export interface RenderColumnSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RenderColumnWhereInput;
  AND?:
    | RenderColumnSubscriptionWhereInput[]
    | RenderColumnSubscriptionWhereInput;
  OR?:
    | RenderColumnSubscriptionWhereInput[]
    | RenderColumnSubscriptionWhereInput;
  NOT?:
    | RenderColumnSubscriptionWhereInput[]
    | RenderColumnSubscriptionWhereInput;
}

export interface BizRelationUpdateWithoutOppositeObjectDataInput {
  incomingObject?: BusinessObjectUpdateOneWithoutOutgoingRelationsInput;
  metaRelation?: MetaRelationUpdateOneWithoutBizRelationsInput;
  oppositeRelation?: BizRelationUpdateOneWithoutOppositeRelationInput;
}

export interface PlanConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlanConfigWhereInput;
  AND?: PlanConfigSubscriptionWhereInput[] | PlanConfigSubscriptionWhereInput;
  OR?: PlanConfigSubscriptionWhereInput[] | PlanConfigSubscriptionWhereInput;
  NOT?: PlanConfigSubscriptionWhereInput[] | PlanConfigSubscriptionWhereInput;
}

export interface BusinessObjectUpdateOneWithoutOutgoingRelationsInput {
  create?: BusinessObjectCreateWithoutOutgoingRelationsInput;
  update?: BusinessObjectUpdateWithoutOutgoingRelationsDataInput;
  upsert?: BusinessObjectUpsertWithoutOutgoingRelationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface MetaRelationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MetaRelationWhereInput;
  AND?:
    | MetaRelationSubscriptionWhereInput[]
    | MetaRelationSubscriptionWhereInput;
  OR?:
    | MetaRelationSubscriptionWhereInput[]
    | MetaRelationSubscriptionWhereInput;
  NOT?:
    | MetaRelationSubscriptionWhereInput[]
    | MetaRelationSubscriptionWhereInput;
}

export interface BusinessObjectUpdateWithoutOutgoingRelationsDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export interface MetaAttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MetaAttributeWhereInput;
  AND?:
    | MetaAttributeSubscriptionWhereInput[]
    | MetaAttributeSubscriptionWhereInput;
  OR?:
    | MetaAttributeSubscriptionWhereInput[]
    | MetaAttributeSubscriptionWhereInput;
  NOT?:
    | MetaAttributeSubscriptionWhereInput[]
    | MetaAttributeSubscriptionWhereInput;
}

export interface BizAttributeUpdateManyWithoutBusinessObjectInput {
  create?:
    | BizAttributeCreateWithoutBusinessObjectInput[]
    | BizAttributeCreateWithoutBusinessObjectInput;
  delete?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  connect?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  set?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  disconnect?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  update?:
    | BizAttributeUpdateWithWhereUniqueWithoutBusinessObjectInput[]
    | BizAttributeUpdateWithWhereUniqueWithoutBusinessObjectInput;
  upsert?:
    | BizAttributeUpsertWithWhereUniqueWithoutBusinessObjectInput[]
    | BizAttributeUpsertWithWhereUniqueWithoutBusinessObjectInput;
  deleteMany?: BizAttributeScalarWhereInput[] | BizAttributeScalarWhereInput;
  updateMany?:
    | BizAttributeUpdateManyWithWhereNestedInput[]
    | BizAttributeUpdateManyWithWhereNestedInput;
}

export type BizRelationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BizAttributeUpdateWithWhereUniqueWithoutBusinessObjectInput {
  where: BizAttributeWhereUniqueInput;
  data: BizAttributeUpdateWithoutBusinessObjectDataInput;
}

export interface BizRelationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BizRelationWhereInput;
  AND?: BizRelationSubscriptionWhereInput[] | BizRelationSubscriptionWhereInput;
  OR?: BizRelationSubscriptionWhereInput[] | BizRelationSubscriptionWhereInput;
  NOT?: BizRelationSubscriptionWhereInput[] | BizRelationSubscriptionWhereInput;
}

export interface BizAttributeUpdateWithoutBusinessObjectDataInput {
  metaAttribute?: MetaAttributeUpdateOneWithoutBizAttributesInput;
  value?: String;
}

export type BusinessObjectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaAttributeUpdateOneWithoutBizAttributesInput {
  create?: MetaAttributeCreateWithoutBizAttributesInput;
  update?: MetaAttributeUpdateWithoutBizAttributesDataInput;
  upsert?: MetaAttributeUpsertWithoutBizAttributesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaAttributeWhereUniqueInput;
}

export interface WidgetUpdateInput {
  name?: String;
  type?: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
}

export interface MetaAttributeUpdateWithoutBizAttributesDataInput {
  name?: String;
  objects?: MetaObjectUpdateManyWithoutAttributesInput;
  type?: AttributeType;
}

export type DiagramWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaObjectUpdateManyWithoutAttributesInput {
  create?:
    | MetaObjectCreateWithoutAttributesInput[]
    | MetaObjectCreateWithoutAttributesInput;
  delete?: MetaObjectWhereUniqueInput[] | MetaObjectWhereUniqueInput;
  connect?: MetaObjectWhereUniqueInput[] | MetaObjectWhereUniqueInput;
  set?: MetaObjectWhereUniqueInput[] | MetaObjectWhereUniqueInput;
  disconnect?: MetaObjectWhereUniqueInput[] | MetaObjectWhereUniqueInput;
  update?:
    | MetaObjectUpdateWithWhereUniqueWithoutAttributesInput[]
    | MetaObjectUpdateWithWhereUniqueWithoutAttributesInput;
  upsert?:
    | MetaObjectUpsertWithWhereUniqueWithoutAttributesInput[]
    | MetaObjectUpsertWithWhereUniqueWithoutAttributesInput;
  deleteMany?: MetaObjectScalarWhereInput[] | MetaObjectScalarWhereInput;
  updateMany?:
    | MetaObjectUpdateManyWithWhereNestedInput[]
    | MetaObjectUpdateManyWithWhereNestedInput;
}

export interface UserCreateInput {
  id?: ID_Input;
  userid?: String;
  password?: String;
  name?: String;
}

export interface MetaObjectUpdateWithWhereUniqueWithoutAttributesInput {
  where: MetaObjectWhereUniqueInput;
  data: MetaObjectUpdateWithoutAttributesDataInput;
}

export type MetaAttributeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface MetaObjectUpdateWithoutAttributesDataInput {
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export interface BusinessObjectUpdateOneInput {
  create?: BusinessObjectCreateInput;
  update?: BusinessObjectUpdateDataInput;
  upsert?: BusinessObjectUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface BusinessObjectUpdateManyWithoutMetaObjectInput {
  create?:
    | BusinessObjectCreateWithoutMetaObjectInput[]
    | BusinessObjectCreateWithoutMetaObjectInput;
  delete?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  connect?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  set?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  disconnect?:
    | BusinessObjectWhereUniqueInput[]
    | BusinessObjectWhereUniqueInput;
  update?:
    | BusinessObjectUpdateWithWhereUniqueWithoutMetaObjectInput[]
    | BusinessObjectUpdateWithWhereUniqueWithoutMetaObjectInput;
  upsert?:
    | BusinessObjectUpsertWithWhereUniqueWithoutMetaObjectInput[]
    | BusinessObjectUpsertWithWhereUniqueWithoutMetaObjectInput;
  deleteMany?:
    | BusinessObjectScalarWhereInput[]
    | BusinessObjectScalarWhereInput;
  updateMany?:
    | BusinessObjectUpdateManyWithWhereNestedInput[]
    | BusinessObjectUpdateManyWithWhereNestedInput;
}

export type MetaObjectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BusinessObjectUpdateWithWhereUniqueWithoutMetaObjectInput {
  where: BusinessObjectWhereUniqueInput;
  data: BusinessObjectUpdateWithoutMetaObjectDataInput;
}

export interface TemplateMappingCreateInput {
  id?: ID_Input;
  template?: TemplateCreateOneInput;
  businessObject?: BusinessObjectCreateOneInput;
}

export interface BusinessObjectUpdateWithoutMetaObjectDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export type MetaRelationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BizRelationUpdateManyWithoutIncomingObjectInput {
  create?:
    | BizRelationCreateWithoutIncomingObjectInput[]
    | BizRelationCreateWithoutIncomingObjectInput;
  delete?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  connect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  set?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  disconnect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  update?:
    | BizRelationUpdateWithWhereUniqueWithoutIncomingObjectInput[]
    | BizRelationUpdateWithWhereUniqueWithoutIncomingObjectInput;
  upsert?:
    | BizRelationUpsertWithWhereUniqueWithoutIncomingObjectInput[]
    | BizRelationUpsertWithWhereUniqueWithoutIncomingObjectInput;
  deleteMany?: BizRelationScalarWhereInput[] | BizRelationScalarWhereInput;
}

export interface TemplateUpdateManyMutationInput {
  name?: String;
}

export interface BizRelationUpdateWithWhereUniqueWithoutIncomingObjectInput {
  where: BizRelationWhereUniqueInput;
  data: BizRelationUpdateWithoutIncomingObjectDataInput;
}

export type PlanWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BizRelationUpdateWithoutIncomingObjectDataInput {
  metaRelation?: MetaRelationUpdateOneWithoutBizRelationsInput;
  oppositeObject?: BusinessObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: BizRelationUpdateOneWithoutOppositeRelationInput;
}

export interface MetaObjectUpsertWithoutTemplateConfigInput {
  update: MetaObjectUpdateWithoutTemplateConfigDataInput;
  create: MetaObjectCreateWithoutTemplateConfigInput;
}

export interface MetaRelationUpdateOneWithoutBizRelationsInput {
  create?: MetaRelationCreateWithoutBizRelationsInput;
  update?: MetaRelationUpdateWithoutBizRelationsDataInput;
  upsert?: MetaRelationUpsertWithoutBizRelationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaRelationWhereUniqueInput;
}

export interface MetaObjectUpdateOneWithoutTemplateConfigInput {
  create?: MetaObjectCreateWithoutTemplateConfigInput;
  update?: MetaObjectUpdateWithoutTemplateConfigDataInput;
  upsert?: MetaObjectUpsertWithoutTemplateConfigInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaObjectWhereUniqueInput;
}

export interface MetaRelationUpdateWithoutBizRelationsDataInput {
  incomingObject?: MetaObjectUpdateOneWithoutOutgoingRelationsInput;
  multiplicity?: MultiplicityType;
  oppositeName?: String;
  oppositeObject?: MetaObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationUpdateOneWithoutOppositeRelationInput;
}

export interface MetaAttributeWhereInput {
  bizAttributes_every?: BizAttributeWhereInput;
  bizAttributes_some?: BizAttributeWhereInput;
  bizAttributes_none?: BizAttributeWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  objects_every?: MetaObjectWhereInput;
  objects_some?: MetaObjectWhereInput;
  objects_none?: MetaObjectWhereInput;
  type?: AttributeType;
  type_not?: AttributeType;
  type_in?: AttributeType[] | AttributeType;
  type_not_in?: AttributeType[] | AttributeType;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MetaAttributeWhereInput[] | MetaAttributeWhereInput;
  OR?: MetaAttributeWhereInput[] | MetaAttributeWhereInput;
  NOT?: MetaAttributeWhereInput[] | MetaAttributeWhereInput;
}

export interface MetaObjectUpdateOneWithoutOutgoingRelationsInput {
  create?: MetaObjectCreateWithoutOutgoingRelationsInput;
  update?: MetaObjectUpdateWithoutOutgoingRelationsDataInput;
  upsert?: MetaObjectUpsertWithoutOutgoingRelationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaObjectWhereUniqueInput;
}

export interface TemplateConfigUpdateOneInput {
  create?: TemplateConfigCreateInput;
  update?: TemplateConfigUpdateDataInput;
  upsert?: TemplateConfigUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TemplateConfigWhereUniqueInput;
}

export interface MetaObjectUpdateWithoutOutgoingRelationsDataInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export type RenderColumnWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaAttributeUpdateManyWithoutObjectsInput {
  create?:
    | MetaAttributeCreateWithoutObjectsInput[]
    | MetaAttributeCreateWithoutObjectsInput;
  delete?: MetaAttributeWhereUniqueInput[] | MetaAttributeWhereUniqueInput;
  connect?: MetaAttributeWhereUniqueInput[] | MetaAttributeWhereUniqueInput;
  set?: MetaAttributeWhereUniqueInput[] | MetaAttributeWhereUniqueInput;
  disconnect?: MetaAttributeWhereUniqueInput[] | MetaAttributeWhereUniqueInput;
  update?:
    | MetaAttributeUpdateWithWhereUniqueWithoutObjectsInput[]
    | MetaAttributeUpdateWithWhereUniqueWithoutObjectsInput;
  upsert?:
    | MetaAttributeUpsertWithWhereUniqueWithoutObjectsInput[]
    | MetaAttributeUpsertWithWhereUniqueWithoutObjectsInput;
  deleteMany?: MetaAttributeScalarWhereInput[] | MetaAttributeScalarWhereInput;
  updateMany?:
    | MetaAttributeUpdateManyWithWhereNestedInput[]
    | MetaAttributeUpdateManyWithWhereNestedInput;
}

export interface MetaAttributeUpdateOneInput {
  create?: MetaAttributeCreateInput;
  update?: MetaAttributeUpdateDataInput;
  upsert?: MetaAttributeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaAttributeWhereUniqueInput;
}

export interface MetaAttributeUpdateWithWhereUniqueWithoutObjectsInput {
  where: MetaAttributeWhereUniqueInput;
  data: MetaAttributeUpdateWithoutObjectsDataInput;
}

export type SMTransitionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaAttributeUpdateWithoutObjectsDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutMetaAttributeInput;
  name?: String;
  type?: AttributeType;
}

export interface MetaObjectUpdateOneInput {
  create?: MetaObjectCreateInput;
  update?: MetaObjectUpdateDataInput;
  upsert?: MetaObjectUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaObjectWhereUniqueInput;
}

export interface BizAttributeUpdateManyWithoutMetaAttributeInput {
  create?:
    | BizAttributeCreateWithoutMetaAttributeInput[]
    | BizAttributeCreateWithoutMetaAttributeInput;
  delete?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  connect?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  set?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  disconnect?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
  update?:
    | BizAttributeUpdateWithWhereUniqueWithoutMetaAttributeInput[]
    | BizAttributeUpdateWithWhereUniqueWithoutMetaAttributeInput;
  upsert?:
    | BizAttributeUpsertWithWhereUniqueWithoutMetaAttributeInput[]
    | BizAttributeUpsertWithWhereUniqueWithoutMetaAttributeInput;
  deleteMany?: BizAttributeScalarWhereInput[] | BizAttributeScalarWhereInput;
  updateMany?:
    | BizAttributeUpdateManyWithWhereNestedInput[]
    | BizAttributeUpdateManyWithWhereNestedInput;
}

export interface StateMachineSchemaWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  finalState?: String;
  finalState_not?: String;
  finalState_in?: String[] | String;
  finalState_not_in?: String[] | String;
  finalState_lt?: String;
  finalState_lte?: String;
  finalState_gt?: String;
  finalState_gte?: String;
  finalState_contains?: String;
  finalState_not_contains?: String;
  finalState_starts_with?: String;
  finalState_not_starts_with?: String;
  finalState_ends_with?: String;
  finalState_not_ends_with?: String;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  initialState?: String;
  initialState_not?: String;
  initialState_in?: String[] | String;
  initialState_not_in?: String[] | String;
  initialState_lt?: String;
  initialState_lte?: String;
  initialState_gt?: String;
  initialState_gte?: String;
  initialState_contains?: String;
  initialState_not_contains?: String;
  initialState_starts_with?: String;
  initialState_not_starts_with?: String;
  initialState_ends_with?: String;
  initialState_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  sMTransitions_every?: SMTransitionWhereInput;
  sMTransitions_some?: SMTransitionWhereInput;
  sMTransitions_none?: SMTransitionWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: StateMachineSchemaWhereInput[] | StateMachineSchemaWhereInput;
  OR?: StateMachineSchemaWhereInput[] | StateMachineSchemaWhereInput;
  NOT?: StateMachineSchemaWhereInput[] | StateMachineSchemaWhereInput;
}

export interface BizAttributeUpdateWithWhereUniqueWithoutMetaAttributeInput {
  where: BizAttributeWhereUniqueInput;
  data: BizAttributeUpdateWithoutMetaAttributeDataInput;
}

export interface SystemSetupUpdateInput {
  systemUserMOMapping?: MetaObjectUpdateOneInput;
  systemUseridMAMapping?: MetaAttributeUpdateOneInput;
  templateConfig?: TemplateConfigUpdateOneInput;
}

export interface BizAttributeUpdateWithoutMetaAttributeDataInput {
  businessObject?: BusinessObjectUpdateOneWithoutBizAttributesInput;
  value?: String;
}

export interface MetaObjectCreateOneWithoutTemplateConfigInput {
  create?: MetaObjectCreateWithoutTemplateConfigInput;
  connect?: MetaObjectWhereUniqueInput;
}

export interface BizAttributeUpsertWithWhereUniqueWithoutMetaAttributeInput {
  where: BizAttributeWhereUniqueInput;
  update: BizAttributeUpdateWithoutMetaAttributeDataInput;
  create: BizAttributeCreateWithoutMetaAttributeInput;
}

export interface MetaRelationWhereInput {
  bizRelations_every?: BizRelationWhereInput;
  bizRelations_some?: BizRelationWhereInput;
  bizRelations_none?: BizRelationWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  incomingObject?: MetaObjectWhereInput;
  multiplicity?: MultiplicityType;
  multiplicity_not?: MultiplicityType;
  multiplicity_in?: MultiplicityType[] | MultiplicityType;
  multiplicity_not_in?: MultiplicityType[] | MultiplicityType;
  oppositeName?: String;
  oppositeName_not?: String;
  oppositeName_in?: String[] | String;
  oppositeName_not_in?: String[] | String;
  oppositeName_lt?: String;
  oppositeName_lte?: String;
  oppositeName_gt?: String;
  oppositeName_gte?: String;
  oppositeName_contains?: String;
  oppositeName_not_contains?: String;
  oppositeName_starts_with?: String;
  oppositeName_not_starts_with?: String;
  oppositeName_ends_with?: String;
  oppositeName_not_ends_with?: String;
  oppositeObject?: MetaObjectWhereInput;
  oppositeRelation?: MetaRelationWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MetaRelationWhereInput[] | MetaRelationWhereInput;
  OR?: MetaRelationWhereInput[] | MetaRelationWhereInput;
  NOT?: MetaRelationWhereInput[] | MetaRelationWhereInput;
}

export interface BizAttributeScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: BizAttributeScalarWhereInput[] | BizAttributeScalarWhereInput;
  OR?: BizAttributeScalarWhereInput[] | BizAttributeScalarWhereInput;
  NOT?: BizAttributeScalarWhereInput[] | BizAttributeScalarWhereInput;
}

export interface TemplateConfigCreateOneInput {
  create?: TemplateConfigCreateInput;
  connect?: TemplateConfigWhereUniqueInput;
}

export interface BizAttributeUpdateManyWithWhereNestedInput {
  where: BizAttributeScalarWhereInput;
  data: BizAttributeUpdateManyDataInput;
}

export type SystemSetupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BizAttributeUpdateManyDataInput {
  value?: String;
}

export interface SystemSetupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  systemUserMOMapping?: MetaObjectWhereInput;
  systemUseridMAMapping?: MetaAttributeWhereInput;
  templateConfig?: TemplateConfigWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SystemSetupWhereInput[] | SystemSetupWhereInput;
  OR?: SystemSetupWhereInput[] | SystemSetupWhereInput;
  NOT?: SystemSetupWhereInput[] | SystemSetupWhereInput;
}

export interface MetaAttributeUpsertWithWhereUniqueWithoutObjectsInput {
  where: MetaAttributeWhereUniqueInput;
  update: MetaAttributeUpdateWithoutObjectsDataInput;
  create: MetaAttributeCreateWithoutObjectsInput;
}

export interface SystemSetupCreateInput {
  id?: ID_Input;
  systemUserMOMapping?: MetaObjectCreateOneInput;
  systemUseridMAMapping?: MetaAttributeCreateOneInput;
  templateConfig?: TemplateConfigCreateOneInput;
}

export interface MetaAttributeScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  type?: AttributeType;
  type_not?: AttributeType;
  type_in?: AttributeType[] | AttributeType;
  type_not_in?: AttributeType[] | AttributeType;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MetaAttributeScalarWhereInput[] | MetaAttributeScalarWhereInput;
  OR?: MetaAttributeScalarWhereInput[] | MetaAttributeScalarWhereInput;
  NOT?: MetaAttributeScalarWhereInput[] | MetaAttributeScalarWhereInput;
}

export interface SMTransitionUpdateManyDataInput {
  event?: String;
  from?: String;
  to?: String;
}

export interface MetaAttributeUpdateManyWithWhereNestedInput {
  where: MetaAttributeScalarWhereInput;
  data: MetaAttributeUpdateManyDataInput;
}

export interface SMTransitionUpdateManyWithWhereNestedInput {
  where: SMTransitionScalarWhereInput;
  data: SMTransitionUpdateManyDataInput;
}

export interface MetaAttributeUpdateManyDataInput {
  name?: String;
  type?: AttributeType;
}

export interface SMTransitionUpsertWithWhereUniqueWithoutStateMachineSchemaInput {
  where: SMTransitionWhereUniqueInput;
  update: SMTransitionUpdateWithoutStateMachineSchemaDataInput;
  create: SMTransitionCreateWithoutStateMachineSchemaInput;
}

export interface RenderColumnUpdateInput {
  widgets?: WidgetUpdateManyInput;
  width?: Int;
}

export type TemplateConfigWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaRelationUpdateWithWhereUniqueWithoutOppositeObjectInput {
  where: MetaRelationWhereUniqueInput;
  data: MetaRelationUpdateWithoutOppositeObjectDataInput;
}

export interface SMTransitionUpdateWithWhereUniqueWithoutStateMachineSchemaInput {
  where: SMTransitionWhereUniqueInput;
  data: SMTransitionUpdateWithoutStateMachineSchemaDataInput;
}

export interface MetaRelationUpdateWithoutOppositeObjectDataInput {
  bizRelations?: BizRelationUpdateManyWithoutMetaRelationInput;
  incomingObject?: MetaObjectUpdateOneWithoutOutgoingRelationsInput;
  multiplicity?: MultiplicityType;
  oppositeName?: String;
  oppositeRelation?: MetaRelationUpdateOneWithoutOppositeRelationInput;
}

export interface StateMachineSchemaUpdateInput {
  finalState?: String;
  initialState?: String;
  name?: String;
  sMTransitions?: SMTransitionUpdateManyWithoutStateMachineSchemaInput;
}

export interface BizRelationUpdateManyWithoutMetaRelationInput {
  create?:
    | BizRelationCreateWithoutMetaRelationInput[]
    | BizRelationCreateWithoutMetaRelationInput;
  delete?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  connect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  set?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  disconnect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
  update?:
    | BizRelationUpdateWithWhereUniqueWithoutMetaRelationInput[]
    | BizRelationUpdateWithWhereUniqueWithoutMetaRelationInput;
  upsert?:
    | BizRelationUpsertWithWhereUniqueWithoutMetaRelationInput[]
    | BizRelationUpsertWithWhereUniqueWithoutMetaRelationInput;
  deleteMany?: BizRelationScalarWhereInput[] | BizRelationScalarWhereInput;
}

export interface SMTransitionCreateWithoutStateMachineSchemaInput {
  event: String;
  from: String;
  id?: ID_Input;
  to: String;
}

export interface BizRelationUpdateWithWhereUniqueWithoutMetaRelationInput {
  where: BizRelationWhereUniqueInput;
  data: BizRelationUpdateWithoutMetaRelationDataInput;
}

export interface BizAttributeWhereInput {
  businessObject?: BusinessObjectWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  metaAttribute?: MetaAttributeWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: BizAttributeWhereInput[] | BizAttributeWhereInput;
  OR?: BizAttributeWhereInput[] | BizAttributeWhereInput;
  NOT?: BizAttributeWhereInput[] | BizAttributeWhereInput;
}

export interface BizRelationUpdateWithoutMetaRelationDataInput {
  incomingObject?: BusinessObjectUpdateOneWithoutOutgoingRelationsInput;
  oppositeObject?: BusinessObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: BizRelationUpdateOneWithoutOppositeRelationInput;
}

export interface StateMachineSchemaCreateInput {
  finalState: String;
  id?: ID_Input;
  initialState: String;
  name: String;
  sMTransitions?: SMTransitionCreateManyWithoutStateMachineSchemaInput;
}

export interface BusinessObjectUpdateOneWithoutIncomingRelationsInput {
  create?: BusinessObjectCreateWithoutIncomingRelationsInput;
  update?: BusinessObjectUpdateWithoutIncomingRelationsDataInput;
  upsert?: BusinessObjectUpsertWithoutIncomingRelationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BusinessObjectWhereUniqueInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  userid?: String;
  name?: String;
}>;

export interface BusinessObjectUpdateWithoutIncomingRelationsDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userid?: String;
  userid_not?: String;
  userid_in?: String[] | String;
  userid_not_in?: String[] | String;
  userid_lt?: String;
  userid_lte?: String;
  userid_gt?: String;
  userid_gte?: String;
  userid_contains?: String;
  userid_not_contains?: String;
  userid_starts_with?: String;
  userid_not_starts_with?: String;
  userid_ends_with?: String;
  userid_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface MetaObjectUpdateOneWithoutBusinessObjectsInput {
  create?: MetaObjectCreateWithoutBusinessObjectsInput;
  update?: MetaObjectUpdateWithoutBusinessObjectsDataInput;
  upsert?: MetaObjectUpsertWithoutBusinessObjectsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaObjectWhereUniqueInput;
}

export interface StateMachineSchemaUpdateOneWithoutSMTransitionsInput {
  create?: StateMachineSchemaCreateWithoutSMTransitionsInput;
  update?: StateMachineSchemaUpdateWithoutSMTransitionsDataInput;
  upsert?: StateMachineSchemaUpsertWithoutSMTransitionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StateMachineSchemaWhereUniqueInput;
}

export interface MetaObjectUpdateWithoutBusinessObjectsDataInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export interface StateMachineSchemaCreateWithoutSMTransitionsInput {
  finalState: String;
  id?: ID_Input;
  initialState: String;
  name: String;
}

export interface MetaRelationUpdateManyWithoutIncomingObjectInput {
  create?:
    | MetaRelationCreateWithoutIncomingObjectInput[]
    | MetaRelationCreateWithoutIncomingObjectInput;
  delete?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  connect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  set?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  disconnect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  update?:
    | MetaRelationUpdateWithWhereUniqueWithoutIncomingObjectInput[]
    | MetaRelationUpdateWithWhereUniqueWithoutIncomingObjectInput;
  upsert?:
    | MetaRelationUpsertWithWhereUniqueWithoutIncomingObjectInput[]
    | MetaRelationUpsertWithWhereUniqueWithoutIncomingObjectInput;
  deleteMany?: MetaRelationScalarWhereInput[] | MetaRelationScalarWhereInput;
  updateMany?:
    | MetaRelationUpdateManyWithWhereNestedInput[]
    | MetaRelationUpdateManyWithWhereNestedInput;
}

export interface StateMachineSchemaCreateOneWithoutSMTransitionsInput {
  create?: StateMachineSchemaCreateWithoutSMTransitionsInput;
  connect?: StateMachineSchemaWhereUniqueInput;
}

export interface MetaRelationUpdateWithWhereUniqueWithoutIncomingObjectInput {
  where: MetaRelationWhereUniqueInput;
  data: MetaRelationUpdateWithoutIncomingObjectDataInput;
}

export interface RenderColumnUpdateManyMutationInput {
  width?: Int;
}

export interface MetaObjectUpsertWithoutPlanConfigInput {
  update: MetaObjectUpdateWithoutPlanConfigDataInput;
  create: MetaObjectCreateWithoutPlanConfigInput;
}

export interface BizAttributeCreateInput {
  businessObject?: BusinessObjectCreateOneWithoutBizAttributesInput;
  id?: ID_Input;
  metaAttribute?: MetaAttributeCreateOneWithoutBizAttributesInput;
  value: String;
}

export interface MetaObjectUpdateWithoutPlanConfigDataInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export interface BusinessObjectCreateWithoutBizAttributesInput {
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface MetaObjectUpdateWithoutIncomingRelationsDataInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export interface BizRelationCreateWithoutOppositeObjectInput {
  id?: ID_Input;
  incomingObject?: BusinessObjectCreateOneWithoutOutgoingRelationsInput;
  metaRelation?: MetaRelationCreateOneWithoutBizRelationsInput;
  oppositeRelation?: BizRelationCreateOneWithoutOppositeRelationInput;
}

export interface PlanConfigUpdateOneWithoutUiMoPlanInput {
  create?: PlanConfigCreateWithoutUiMoPlanInput;
  update?: PlanConfigUpdateWithoutUiMoPlanDataInput;
  upsert?: PlanConfigUpsertWithoutUiMoPlanInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlanConfigWhereUniqueInput;
}

export interface BusinessObjectCreateWithoutOutgoingRelationsInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface PlanConfigUpdateWithoutUiMoPlanDataInput {
  uiMoRelations?: MetaRelationUpdateManyInput;
}

export interface BizAttributeCreateWithoutBusinessObjectInput {
  id?: ID_Input;
  metaAttribute?: MetaAttributeCreateOneWithoutBizAttributesInput;
  value: String;
}

export interface MetaRelationUpdateManyInput {
  create?: MetaRelationCreateInput[] | MetaRelationCreateInput;
  update?:
    | MetaRelationUpdateWithWhereUniqueNestedInput[]
    | MetaRelationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | MetaRelationUpsertWithWhereUniqueNestedInput[]
    | MetaRelationUpsertWithWhereUniqueNestedInput;
  delete?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  connect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  set?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  disconnect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
  deleteMany?: MetaRelationScalarWhereInput[] | MetaRelationScalarWhereInput;
  updateMany?:
    | MetaRelationUpdateManyWithWhereNestedInput[]
    | MetaRelationUpdateManyWithWhereNestedInput;
}

export interface MetaAttributeCreateWithoutBizAttributesInput {
  id?: ID_Input;
  name?: String;
  objects?: MetaObjectCreateManyWithoutAttributesInput;
  type?: AttributeType;
}

export interface MetaRelationUpdateWithWhereUniqueNestedInput {
  where: MetaRelationWhereUniqueInput;
  data: MetaRelationUpdateDataInput;
}

export interface MetaObjectCreateWithoutAttributesInput {
  businessObjects?: BusinessObjectCreateManyWithoutMetaObjectInput;
  id?: ID_Input;
  incomingRelations?: MetaRelationCreateManyWithoutOppositeObjectInput;
  name: String;
  outgoingRelations?: MetaRelationCreateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigCreateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigCreateOneWithoutMoObjectInput;
}

export interface MetaRelationUpdateDataInput {
  bizRelations?: BizRelationUpdateManyWithoutMetaRelationInput;
  incomingObject?: MetaObjectUpdateOneWithoutOutgoingRelationsInput;
  multiplicity?: MultiplicityType;
  oppositeName?: String;
  oppositeObject?: MetaObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationUpdateOneWithoutOppositeRelationInput;
}

export interface BusinessObjectCreateWithoutMetaObjectInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface MetaRelationUpdateOneWithoutOppositeRelationInput {
  create?: MetaRelationCreateWithoutOppositeRelationInput;
  update?: MetaRelationUpdateWithoutOppositeRelationDataInput;
  upsert?: MetaRelationUpsertWithoutOppositeRelationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaRelationWhereUniqueInput;
}

export interface BizRelationCreateWithoutIncomingObjectInput {
  id?: ID_Input;
  metaRelation?: MetaRelationCreateOneWithoutBizRelationsInput;
  oppositeObject?: BusinessObjectCreateOneWithoutIncomingRelationsInput;
  oppositeRelation?: BizRelationCreateOneWithoutOppositeRelationInput;
}

export interface MetaRelationUpdateWithoutOppositeRelationDataInput {
  bizRelations?: BizRelationUpdateManyWithoutMetaRelationInput;
  incomingObject?: MetaObjectUpdateOneWithoutOutgoingRelationsInput;
  multiplicity?: MultiplicityType;
  oppositeName?: String;
  oppositeObject?: MetaObjectUpdateOneWithoutIncomingRelationsInput;
}

export interface MetaRelationCreateWithoutBizRelationsInput {
  id?: ID_Input;
  incomingObject?: MetaObjectCreateOneWithoutOutgoingRelationsInput;
  multiplicity: MultiplicityType;
  oppositeName: String;
  oppositeObject?: MetaObjectCreateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationCreateOneWithoutOppositeRelationInput;
}

export interface MetaRelationUpsertWithoutOppositeRelationInput {
  update: MetaRelationUpdateWithoutOppositeRelationDataInput;
  create: MetaRelationCreateWithoutOppositeRelationInput;
}

export interface MetaObjectCreateWithoutOutgoingRelationsInput {
  attributes?: MetaAttributeCreateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectCreateManyWithoutMetaObjectInput;
  id?: ID_Input;
  incomingRelations?: MetaRelationCreateManyWithoutOppositeObjectInput;
  name: String;
  planConfig?: PlanConfigCreateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigCreateOneWithoutMoObjectInput;
}

export interface MetaRelationUpsertWithWhereUniqueNestedInput {
  where: MetaRelationWhereUniqueInput;
  update: MetaRelationUpdateDataInput;
  create: MetaRelationCreateInput;
}

export interface MetaAttributeCreateWithoutObjectsInput {
  bizAttributes?: BizAttributeCreateManyWithoutMetaAttributeInput;
  id?: ID_Input;
  name?: String;
  type?: AttributeType;
}

export interface MetaRelationScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  multiplicity?: MultiplicityType;
  multiplicity_not?: MultiplicityType;
  multiplicity_in?: MultiplicityType[] | MultiplicityType;
  multiplicity_not_in?: MultiplicityType[] | MultiplicityType;
  oppositeName?: String;
  oppositeName_not?: String;
  oppositeName_in?: String[] | String;
  oppositeName_not_in?: String[] | String;
  oppositeName_lt?: String;
  oppositeName_lte?: String;
  oppositeName_gt?: String;
  oppositeName_gte?: String;
  oppositeName_contains?: String;
  oppositeName_not_contains?: String;
  oppositeName_starts_with?: String;
  oppositeName_not_starts_with?: String;
  oppositeName_ends_with?: String;
  oppositeName_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MetaRelationScalarWhereInput[] | MetaRelationScalarWhereInput;
  OR?: MetaRelationScalarWhereInput[] | MetaRelationScalarWhereInput;
  NOT?: MetaRelationScalarWhereInput[] | MetaRelationScalarWhereInput;
}

export interface BizAttributeCreateWithoutMetaAttributeInput {
  businessObject?: BusinessObjectCreateOneWithoutBizAttributesInput;
  id?: ID_Input;
  value: String;
}

export interface MetaRelationUpdateManyWithWhereNestedInput {
  where: MetaRelationScalarWhereInput;
  data: MetaRelationUpdateManyDataInput;
}

export interface MetaRelationCreateWithoutOppositeObjectInput {
  bizRelations?: BizRelationCreateManyWithoutMetaRelationInput;
  id?: ID_Input;
  incomingObject?: MetaObjectCreateOneWithoutOutgoingRelationsInput;
  multiplicity: MultiplicityType;
  oppositeName: String;
  oppositeRelation?: MetaRelationCreateOneWithoutOppositeRelationInput;
}

export interface MetaRelationUpdateManyDataInput {
  multiplicity?: MultiplicityType;
  oppositeName?: String;
}

export interface BizRelationCreateWithoutMetaRelationInput {
  id?: ID_Input;
  incomingObject?: BusinessObjectCreateOneWithoutOutgoingRelationsInput;
  oppositeObject?: BusinessObjectCreateOneWithoutIncomingRelationsInput;
  oppositeRelation?: BizRelationCreateOneWithoutOppositeRelationInput;
}

export interface PlanConfigUpsertWithoutUiMoPlanInput {
  update: PlanConfigUpdateWithoutUiMoPlanDataInput;
  create: PlanConfigCreateWithoutUiMoPlanInput;
}

export interface BusinessObjectCreateWithoutIncomingRelationsInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface TemplateConfigUpdateOneWithoutMoObjectInput {
  create?: TemplateConfigCreateWithoutMoObjectInput;
  update?: TemplateConfigUpdateWithoutMoObjectDataInput;
  upsert?: TemplateConfigUpsertWithoutMoObjectInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TemplateConfigWhereUniqueInput;
}

export interface MetaObjectCreateWithoutBusinessObjectsInput {
  attributes?: MetaAttributeCreateManyWithoutObjectsInput;
  id?: ID_Input;
  incomingRelations?: MetaRelationCreateManyWithoutOppositeObjectInput;
  name: String;
  outgoingRelations?: MetaRelationCreateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigCreateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigCreateOneWithoutMoObjectInput;
}

export interface TemplateConfigUpdateWithoutMoObjectDataInput {
  moRelation?: MetaRelationUpdateOneInput;
  userRelatedMRId?: String;
  defaultTemplate?: TemplateUpdateOneInput;
}

export interface MetaRelationCreateWithoutIncomingObjectInput {
  bizRelations?: BizRelationCreateManyWithoutMetaRelationInput;
  id?: ID_Input;
  multiplicity: MultiplicityType;
  oppositeName: String;
  oppositeObject?: MetaObjectCreateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationCreateOneWithoutOppositeRelationInput;
}

export interface MetaRelationUpdateOneInput {
  create?: MetaRelationCreateInput;
  update?: MetaRelationUpdateDataInput;
  upsert?: MetaRelationUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaRelationWhereUniqueInput;
}

export interface MetaObjectCreateWithoutIncomingRelationsInput {
  attributes?: MetaAttributeCreateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectCreateManyWithoutMetaObjectInput;
  id?: ID_Input;
  name: String;
  outgoingRelations?: MetaRelationCreateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigCreateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigCreateOneWithoutMoObjectInput;
}

export interface MetaRelationUpsertNestedInput {
  update: MetaRelationUpdateDataInput;
  create: MetaRelationCreateInput;
}

export interface PlanConfigCreateWithoutUiMoPlanInput {
  id?: ID_Input;
  uiMoRelations?: MetaRelationCreateManyInput;
}

export interface TemplateUpdateOneInput {
  create?: TemplateCreateInput;
  update?: TemplateUpdateDataInput;
  upsert?: TemplateUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TemplateWhereUniqueInput;
}

export interface MetaRelationCreateInput {
  bizRelations?: BizRelationCreateManyWithoutMetaRelationInput;
  id?: ID_Input;
  incomingObject?: MetaObjectCreateOneWithoutOutgoingRelationsInput;
  multiplicity: MultiplicityType;
  oppositeName: String;
  oppositeObject?: MetaObjectCreateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationCreateOneWithoutOppositeRelationInput;
}

export interface TemplateUpdateDataInput {
  name?: String;
  renderColumns?: RenderColumnUpdateManyInput;
}

export interface MetaRelationCreateWithoutOppositeRelationInput {
  bizRelations?: BizRelationCreateManyWithoutMetaRelationInput;
  id?: ID_Input;
  incomingObject?: MetaObjectCreateOneWithoutOutgoingRelationsInput;
  multiplicity: MultiplicityType;
  oppositeName: String;
  oppositeObject?: MetaObjectCreateOneWithoutIncomingRelationsInput;
}

export interface RenderColumnUpdateManyInput {
  create?: RenderColumnCreateInput[] | RenderColumnCreateInput;
  update?:
    | RenderColumnUpdateWithWhereUniqueNestedInput[]
    | RenderColumnUpdateWithWhereUniqueNestedInput;
  upsert?:
    | RenderColumnUpsertWithWhereUniqueNestedInput[]
    | RenderColumnUpsertWithWhereUniqueNestedInput;
  delete?: RenderColumnWhereUniqueInput[] | RenderColumnWhereUniqueInput;
  connect?: RenderColumnWhereUniqueInput[] | RenderColumnWhereUniqueInput;
  set?: RenderColumnWhereUniqueInput[] | RenderColumnWhereUniqueInput;
  disconnect?: RenderColumnWhereUniqueInput[] | RenderColumnWhereUniqueInput;
  deleteMany?: RenderColumnScalarWhereInput[] | RenderColumnScalarWhereInput;
  updateMany?:
    | RenderColumnUpdateManyWithWhereNestedInput[]
    | RenderColumnUpdateManyWithWhereNestedInput;
}

export interface TemplateConfigCreateWithoutMoObjectInput {
  id?: ID_Input;
  moRelation?: MetaRelationCreateOneInput;
  userRelatedMRId?: String;
  defaultTemplate?: TemplateCreateOneInput;
}

export interface RenderColumnUpdateWithWhereUniqueNestedInput {
  where: RenderColumnWhereUniqueInput;
  data: RenderColumnUpdateDataInput;
}

export interface TemplateCreateOneInput {
  create?: TemplateCreateInput;
  connect?: TemplateWhereUniqueInput;
}

export interface RenderColumnUpdateDataInput {
  widgets?: WidgetUpdateManyInput;
  width?: Int;
}

export interface RenderColumnCreateManyInput {
  create?: RenderColumnCreateInput[] | RenderColumnCreateInput;
  connect?: RenderColumnWhereUniqueInput[] | RenderColumnWhereUniqueInput;
}

export interface WidgetUpdateManyInput {
  create?: WidgetCreateInput[] | WidgetCreateInput;
  update?:
    | WidgetUpdateWithWhereUniqueNestedInput[]
    | WidgetUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WidgetUpsertWithWhereUniqueNestedInput[]
    | WidgetUpsertWithWhereUniqueNestedInput;
  delete?: WidgetWhereUniqueInput[] | WidgetWhereUniqueInput;
  connect?: WidgetWhereUniqueInput[] | WidgetWhereUniqueInput;
  set?: WidgetWhereUniqueInput[] | WidgetWhereUniqueInput;
  disconnect?: WidgetWhereUniqueInput[] | WidgetWhereUniqueInput;
  deleteMany?: WidgetScalarWhereInput[] | WidgetScalarWhereInput;
  updateMany?:
    | WidgetUpdateManyWithWhereNestedInput[]
    | WidgetUpdateManyWithWhereNestedInput;
}

export interface WidgetCreateManyInput {
  create?: WidgetCreateInput[] | WidgetCreateInput;
  connect?: WidgetWhereUniqueInput[] | WidgetWhereUniqueInput;
}

export interface WidgetUpdateWithWhereUniqueNestedInput {
  where: WidgetWhereUniqueInput;
  data: WidgetUpdateDataInput;
}

export interface BusinessObjectCreatetagsInput {
  set?: String[] | String;
}

export interface WidgetUpdateDataInput {
  name?: String;
  type?: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
}

export interface PlanCreateWithoutPlanBOInput {
  id?: ID_Input;
  planData?: Json;
  itemBOs?: BusinessObjectCreateManyWithoutPlannedInInput;
}

export interface WidgetUpsertWithWhereUniqueNestedInput {
  where: WidgetWhereUniqueInput;
  update: WidgetUpdateDataInput;
  create: WidgetCreateInput;
}

export interface BusinessObjectCreateWithoutPlannedInInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface WidgetScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  type?: WidgetType;
  type_not?: WidgetType;
  type_in?: WidgetType[] | WidgetType;
  type_not_in?: WidgetType[] | WidgetType;
  width?: Int;
  width_not?: Int;
  width_in?: Int[] | Int;
  width_not_in?: Int[] | Int;
  width_lt?: Int;
  width_lte?: Int;
  width_gt?: Int;
  width_gte?: Int;
  boid?: String;
  boid_not?: String;
  boid_in?: String[] | String;
  boid_not_in?: String[] | String;
  boid_lt?: String;
  boid_lte?: String;
  boid_gt?: String;
  boid_gte?: String;
  boid_contains?: String;
  boid_not_contains?: String;
  boid_starts_with?: String;
  boid_not_starts_with?: String;
  boid_ends_with?: String;
  boid_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: WidgetScalarWhereInput[] | WidgetScalarWhereInput;
  OR?: WidgetScalarWhereInput[] | WidgetScalarWhereInput;
  NOT?: WidgetScalarWhereInput[] | WidgetScalarWhereInput;
}

export interface DiagramCreateWithoutOwnerBOInput {
  id?: ID_Input;
  diagramData?: Json;
  participatingBOs?: BusinessObjectCreateManyWithoutParticipatesInDiagramsInput;
}

export interface WidgetUpdateManyWithWhereNestedInput {
  where: WidgetScalarWhereInput;
  data: WidgetUpdateManyDataInput;
}

export interface BusinessObjectCreateWithoutParticipatesInDiagramsInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
}

export interface WidgetUpdateManyDataInput {
  name?: String;
  type?: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
}

export interface PlanCreateWithoutItemBOsInput {
  id?: ID_Input;
  planData?: Json;
  planBO?: BusinessObjectCreateOneWithoutPlanInput;
}

export interface RenderColumnUpsertWithWhereUniqueNestedInput {
  where: RenderColumnWhereUniqueInput;
  update: RenderColumnUpdateDataInput;
  create: RenderColumnCreateInput;
}

export interface BusinessObjectCreateWithoutPlanInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface RenderColumnScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  width?: Int;
  width_not?: Int;
  width_in?: Int[] | Int;
  width_not_in?: Int[] | Int;
  width_lt?: Int;
  width_lte?: Int;
  width_gt?: Int;
  width_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RenderColumnScalarWhereInput[] | RenderColumnScalarWhereInput;
  OR?: RenderColumnScalarWhereInput[] | RenderColumnScalarWhereInput;
  NOT?: RenderColumnScalarWhereInput[] | RenderColumnScalarWhereInput;
}

export interface DiagramCreateWithoutParticipatingBOsInput {
  id?: ID_Input;
  diagramData?: Json;
  ownerBO?: BusinessObjectCreateOneWithoutOwnsDiagramsInput;
}

export interface RenderColumnUpdateManyWithWhereNestedInput {
  where: RenderColumnScalarWhereInput;
  data: RenderColumnUpdateManyDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface RenderColumnUpdateManyDataInput {
  width?: Int;
}

export interface TemplateConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TemplateConfigWhereInput;
  AND?:
    | TemplateConfigSubscriptionWhereInput[]
    | TemplateConfigSubscriptionWhereInput;
  OR?:
    | TemplateConfigSubscriptionWhereInput[]
    | TemplateConfigSubscriptionWhereInput;
  NOT?:
    | TemplateConfigSubscriptionWhereInput[]
    | TemplateConfigSubscriptionWhereInput;
}

export interface TemplateUpsertNestedInput {
  update: TemplateUpdateDataInput;
  create: TemplateCreateInput;
}

export interface TemplateConfigWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  moObject?: MetaObjectWhereInput;
  moRelation?: MetaRelationWhereInput;
  userRelatedMRId?: String;
  userRelatedMRId_not?: String;
  userRelatedMRId_in?: String[] | String;
  userRelatedMRId_not_in?: String[] | String;
  userRelatedMRId_lt?: String;
  userRelatedMRId_lte?: String;
  userRelatedMRId_gt?: String;
  userRelatedMRId_gte?: String;
  userRelatedMRId_contains?: String;
  userRelatedMRId_not_contains?: String;
  userRelatedMRId_starts_with?: String;
  userRelatedMRId_not_starts_with?: String;
  userRelatedMRId_ends_with?: String;
  userRelatedMRId_not_ends_with?: String;
  defaultTemplate?: TemplateWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TemplateConfigWhereInput[] | TemplateConfigWhereInput;
  OR?: TemplateConfigWhereInput[] | TemplateConfigWhereInput;
  NOT?: TemplateConfigWhereInput[] | TemplateConfigWhereInput;
}

export interface TemplateConfigUpsertWithoutMoObjectInput {
  update: TemplateConfigUpdateWithoutMoObjectDataInput;
  create: TemplateConfigCreateWithoutMoObjectInput;
}

export interface PlanConfigWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  uiMoPlan?: MetaObjectWhereInput;
  uiMoRelations_every?: MetaRelationWhereInput;
  uiMoRelations_some?: MetaRelationWhereInput;
  uiMoRelations_none?: MetaRelationWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PlanConfigWhereInput[] | PlanConfigWhereInput;
  OR?: PlanConfigWhereInput[] | PlanConfigWhereInput;
  NOT?: PlanConfigWhereInput[] | PlanConfigWhereInput;
}

export interface MetaObjectUpsertWithoutIncomingRelationsInput {
  update: MetaObjectUpdateWithoutIncomingRelationsDataInput;
  create: MetaObjectCreateWithoutIncomingRelationsInput;
}

export interface MetaObjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MetaObjectWhereInput;
  AND?: MetaObjectSubscriptionWhereInput[] | MetaObjectSubscriptionWhereInput;
  OR?: MetaObjectSubscriptionWhereInput[] | MetaObjectSubscriptionWhereInput;
  NOT?: MetaObjectSubscriptionWhereInput[] | MetaObjectSubscriptionWhereInput;
}

export interface MetaRelationUpsertWithWhereUniqueWithoutIncomingObjectInput {
  where: MetaRelationWhereUniqueInput;
  update: MetaRelationUpdateWithoutIncomingObjectDataInput;
  create: MetaRelationCreateWithoutIncomingObjectInput;
}

export interface BusinessObjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BusinessObjectWhereInput;
  AND?:
    | BusinessObjectSubscriptionWhereInput[]
    | BusinessObjectSubscriptionWhereInput;
  OR?:
    | BusinessObjectSubscriptionWhereInput[]
    | BusinessObjectSubscriptionWhereInput;
  NOT?:
    | BusinessObjectSubscriptionWhereInput[]
    | BusinessObjectSubscriptionWhereInput;
}

export interface MetaObjectUpsertWithoutBusinessObjectsInput {
  update: MetaObjectUpdateWithoutBusinessObjectsDataInput;
  create: MetaObjectCreateWithoutBusinessObjectsInput;
}

export interface WidgetUpdateManyMutationInput {
  name?: String;
  type?: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
}

export interface BusinessObjectUpdatetagsInput {
  set?: String[] | String;
}

export interface UserUpdateInput {
  userid?: String;
  password?: String;
  name?: String;
}

export interface PlanUpdateOneWithoutPlanBOInput {
  create?: PlanCreateWithoutPlanBOInput;
  update?: PlanUpdateWithoutPlanBODataInput;
  upsert?: PlanUpsertWithoutPlanBOInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlanWhereUniqueInput;
}

export interface BusinessObjectUpdateDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export interface PlanUpdateWithoutPlanBODataInput {
  planData?: Json;
  itemBOs?: BusinessObjectUpdateManyWithoutPlannedInInput;
}

export interface BusinessObjectCreateOneInput {
  create?: BusinessObjectCreateInput;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface BusinessObjectUpdateManyWithoutPlannedInInput {
  create?:
    | BusinessObjectCreateWithoutPlannedInInput[]
    | BusinessObjectCreateWithoutPlannedInInput;
  delete?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  connect?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  set?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  disconnect?:
    | BusinessObjectWhereUniqueInput[]
    | BusinessObjectWhereUniqueInput;
  update?:
    | BusinessObjectUpdateWithWhereUniqueWithoutPlannedInInput[]
    | BusinessObjectUpdateWithWhereUniqueWithoutPlannedInInput;
  upsert?:
    | BusinessObjectUpsertWithWhereUniqueWithoutPlannedInInput[]
    | BusinessObjectUpsertWithWhereUniqueWithoutPlannedInInput;
  deleteMany?:
    | BusinessObjectScalarWhereInput[]
    | BusinessObjectScalarWhereInput;
  updateMany?:
    | BusinessObjectUpdateManyWithWhereNestedInput[]
    | BusinessObjectUpdateManyWithWhereNestedInput;
}

export interface TemplateConfigUpdateInput {
  moObject?: MetaObjectUpdateOneWithoutTemplateConfigInput;
  moRelation?: MetaRelationUpdateOneInput;
  userRelatedMRId?: String;
  defaultTemplate?: TemplateUpdateOneInput;
}

export interface BusinessObjectUpdateWithWhereUniqueWithoutPlannedInInput {
  where: BusinessObjectWhereUniqueInput;
  data: BusinessObjectUpdateWithoutPlannedInDataInput;
}

export interface TemplateConfigUpsertNestedInput {
  update: TemplateConfigUpdateDataInput;
  create: TemplateConfigCreateInput;
}

export interface BusinessObjectUpdateWithoutPlannedInDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export type PlanConfigWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DiagramUpdateManyWithoutOwnerBOInput {
  create?:
    | DiagramCreateWithoutOwnerBOInput[]
    | DiagramCreateWithoutOwnerBOInput;
  delete?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  connect?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  set?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  disconnect?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  update?:
    | DiagramUpdateWithWhereUniqueWithoutOwnerBOInput[]
    | DiagramUpdateWithWhereUniqueWithoutOwnerBOInput;
  upsert?:
    | DiagramUpsertWithWhereUniqueWithoutOwnerBOInput[]
    | DiagramUpsertWithWhereUniqueWithoutOwnerBOInput;
  deleteMany?: DiagramScalarWhereInput[] | DiagramScalarWhereInput;
  updateMany?:
    | DiagramUpdateManyWithWhereNestedInput[]
    | DiagramUpdateManyWithWhereNestedInput;
}

export interface MetaAttributeUpsertNestedInput {
  update: MetaAttributeUpdateDataInput;
  create: MetaAttributeCreateInput;
}

export interface DiagramUpdateWithWhereUniqueWithoutOwnerBOInput {
  where: DiagramWhereUniqueInput;
  data: DiagramUpdateWithoutOwnerBODataInput;
}

export interface MetaObjectUpsertNestedInput {
  update: MetaObjectUpdateDataInput;
  create: MetaObjectCreateInput;
}

export interface DiagramUpdateWithoutOwnerBODataInput {
  diagramData?: Json;
  participatingBOs?: BusinessObjectUpdateManyWithoutParticipatesInDiagramsInput;
}

export interface SMTransitionWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  event?: String;
  event_not?: String;
  event_in?: String[] | String;
  event_not_in?: String[] | String;
  event_lt?: String;
  event_lte?: String;
  event_gt?: String;
  event_gte?: String;
  event_contains?: String;
  event_not_contains?: String;
  event_starts_with?: String;
  event_not_starts_with?: String;
  event_ends_with?: String;
  event_not_ends_with?: String;
  from?: String;
  from_not?: String;
  from_in?: String[] | String;
  from_not_in?: String[] | String;
  from_lt?: String;
  from_lte?: String;
  from_gt?: String;
  from_gte?: String;
  from_contains?: String;
  from_not_contains?: String;
  from_starts_with?: String;
  from_not_starts_with?: String;
  from_ends_with?: String;
  from_not_ends_with?: String;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stateMachineSchema?: StateMachineSchemaWhereInput;
  to?: String;
  to_not?: String;
  to_in?: String[] | String;
  to_not_in?: String[] | String;
  to_lt?: String;
  to_lte?: String;
  to_gt?: String;
  to_gte?: String;
  to_contains?: String;
  to_not_contains?: String;
  to_starts_with?: String;
  to_not_starts_with?: String;
  to_ends_with?: String;
  to_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SMTransitionWhereInput[] | SMTransitionWhereInput;
  OR?: SMTransitionWhereInput[] | SMTransitionWhereInput;
  NOT?: SMTransitionWhereInput[] | SMTransitionWhereInput;
}

export interface BusinessObjectUpdateManyWithoutParticipatesInDiagramsInput {
  create?:
    | BusinessObjectCreateWithoutParticipatesInDiagramsInput[]
    | BusinessObjectCreateWithoutParticipatesInDiagramsInput;
  delete?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  connect?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  set?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
  disconnect?:
    | BusinessObjectWhereUniqueInput[]
    | BusinessObjectWhereUniqueInput;
  update?:
    | BusinessObjectUpdateWithWhereUniqueWithoutParticipatesInDiagramsInput[]
    | BusinessObjectUpdateWithWhereUniqueWithoutParticipatesInDiagramsInput;
  upsert?:
    | BusinessObjectUpsertWithWhereUniqueWithoutParticipatesInDiagramsInput[]
    | BusinessObjectUpsertWithWhereUniqueWithoutParticipatesInDiagramsInput;
  deleteMany?:
    | BusinessObjectScalarWhereInput[]
    | BusinessObjectScalarWhereInput;
  updateMany?:
    | BusinessObjectUpdateManyWithWhereNestedInput[]
    | BusinessObjectUpdateManyWithWhereNestedInput;
}

export interface MetaObjectCreateWithoutTemplateConfigInput {
  attributes?: MetaAttributeCreateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectCreateManyWithoutMetaObjectInput;
  id?: ID_Input;
  incomingRelations?: MetaRelationCreateManyWithoutOppositeObjectInput;
  name: String;
  outgoingRelations?: MetaRelationCreateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigCreateOneWithoutUiMoPlanInput;
}

export interface BusinessObjectUpdateWithWhereUniqueWithoutParticipatesInDiagramsInput {
  where: BusinessObjectWhereUniqueInput;
  data: BusinessObjectUpdateWithoutParticipatesInDiagramsDataInput;
}

export interface TemplateConfigCreateInput {
  id?: ID_Input;
  moObject?: MetaObjectCreateOneWithoutTemplateConfigInput;
  moRelation?: MetaRelationCreateOneInput;
  userRelatedMRId?: String;
  defaultTemplate?: TemplateCreateOneInput;
}

export interface BusinessObjectUpdateWithoutParticipatesInDiagramsDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
}

export interface MetaObjectCreateOneInput {
  create?: MetaObjectCreateInput;
  connect?: MetaObjectWhereUniqueInput;
}

export interface PlanUpdateOneWithoutItemBOsInput {
  create?: PlanCreateWithoutItemBOsInput;
  update?: PlanUpdateWithoutItemBOsDataInput;
  upsert?: PlanUpsertWithoutItemBOsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PlanWhereUniqueInput;
}

export interface StateMachineSchemaUpdateManyMutationInput {
  finalState?: String;
  initialState?: String;
  name?: String;
}

export interface PlanUpdateWithoutItemBOsDataInput {
  planData?: Json;
  planBO?: BusinessObjectUpdateOneWithoutPlanInput;
}

export interface SMTransitionScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  event?: String;
  event_not?: String;
  event_in?: String[] | String;
  event_not_in?: String[] | String;
  event_lt?: String;
  event_lte?: String;
  event_gt?: String;
  event_gte?: String;
  event_contains?: String;
  event_not_contains?: String;
  event_starts_with?: String;
  event_not_starts_with?: String;
  event_ends_with?: String;
  event_not_ends_with?: String;
  from?: String;
  from_not?: String;
  from_in?: String[] | String;
  from_not_in?: String[] | String;
  from_lt?: String;
  from_lte?: String;
  from_gt?: String;
  from_gte?: String;
  from_contains?: String;
  from_not_contains?: String;
  from_starts_with?: String;
  from_not_starts_with?: String;
  from_ends_with?: String;
  from_not_ends_with?: String;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  to?: String;
  to_not?: String;
  to_in?: String[] | String;
  to_not_in?: String[] | String;
  to_lt?: String;
  to_lte?: String;
  to_gt?: String;
  to_gte?: String;
  to_contains?: String;
  to_not_contains?: String;
  to_starts_with?: String;
  to_not_starts_with?: String;
  to_ends_with?: String;
  to_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SMTransitionScalarWhereInput[] | SMTransitionScalarWhereInput;
  OR?: SMTransitionScalarWhereInput[] | SMTransitionScalarWhereInput;
  NOT?: SMTransitionScalarWhereInput[] | SMTransitionScalarWhereInput;
}

export interface BusinessObjectUpdateOneWithoutPlanInput {
  create?: BusinessObjectCreateWithoutPlanInput;
  update?: BusinessObjectUpdateWithoutPlanDataInput;
  upsert?: BusinessObjectUpsertWithoutPlanInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface BusinessObjectWhereInput {
  bizAttributes_every?: BizAttributeWhereInput;
  bizAttributes_some?: BizAttributeWhereInput;
  bizAttributes_none?: BizAttributeWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  incomingRelations_every?: BizRelationWhereInput;
  incomingRelations_some?: BizRelationWhereInput;
  incomingRelations_none?: BizRelationWhereInput;
  metaObject?: MetaObjectWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  outgoingRelations_every?: BizRelationWhereInput;
  outgoingRelations_some?: BizRelationWhereInput;
  outgoingRelations_none?: BizRelationWhereInput;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  plan?: PlanWhereInput;
  plannedIn?: PlanWhereInput;
  ownsDiagrams_every?: DiagramWhereInput;
  ownsDiagrams_some?: DiagramWhereInput;
  ownsDiagrams_none?: DiagramWhereInput;
  participatesInDiagrams_every?: DiagramWhereInput;
  participatesInDiagrams_some?: DiagramWhereInput;
  participatesInDiagrams_none?: DiagramWhereInput;
  AND?: BusinessObjectWhereInput[] | BusinessObjectWhereInput;
  OR?: BusinessObjectWhereInput[] | BusinessObjectWhereInput;
  NOT?: BusinessObjectWhereInput[] | BusinessObjectWhereInput;
}

export interface BusinessObjectUpdateWithoutPlanDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export type TemplateMappingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DiagramUpdateManyWithoutParticipatingBOsInput {
  create?:
    | DiagramCreateWithoutParticipatingBOsInput[]
    | DiagramCreateWithoutParticipatingBOsInput;
  delete?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  connect?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  set?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  disconnect?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
  update?:
    | DiagramUpdateWithWhereUniqueWithoutParticipatingBOsInput[]
    | DiagramUpdateWithWhereUniqueWithoutParticipatingBOsInput;
  upsert?:
    | DiagramUpsertWithWhereUniqueWithoutParticipatingBOsInput[]
    | DiagramUpsertWithWhereUniqueWithoutParticipatingBOsInput;
  deleteMany?: DiagramScalarWhereInput[] | DiagramScalarWhereInput;
  updateMany?:
    | DiagramUpdateManyWithWhereNestedInput[]
    | DiagramUpdateManyWithWhereNestedInput;
}

export interface SMTransitionCreateManyWithoutStateMachineSchemaInput {
  create?:
    | SMTransitionCreateWithoutStateMachineSchemaInput[]
    | SMTransitionCreateWithoutStateMachineSchemaInput;
  connect?: SMTransitionWhereUniqueInput[] | SMTransitionWhereUniqueInput;
}

export interface DiagramUpdateWithWhereUniqueWithoutParticipatingBOsInput {
  where: DiagramWhereUniqueInput;
  data: DiagramUpdateWithoutParticipatingBOsDataInput;
}

export interface StateMachineSchemaUpsertWithoutSMTransitionsInput {
  update: StateMachineSchemaUpdateWithoutSMTransitionsDataInput;
  create: StateMachineSchemaCreateWithoutSMTransitionsInput;
}

export interface DiagramUpdateWithoutParticipatingBOsDataInput {
  diagramData?: Json;
  ownerBO?: BusinessObjectUpdateOneWithoutOwnsDiagramsInput;
}

export interface SMTransitionUpdateInput {
  event?: String;
  from?: String;
  stateMachineSchema?: StateMachineSchemaUpdateOneWithoutSMTransitionsInput;
  to?: String;
}

export interface BusinessObjectUpdateOneWithoutOwnsDiagramsInput {
  create?: BusinessObjectCreateWithoutOwnsDiagramsInput;
  update?: BusinessObjectUpdateWithoutOwnsDiagramsDataInput;
  upsert?: BusinessObjectUpsertWithoutOwnsDiagramsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface SMTransitionCreateInput {
  event: String;
  from: String;
  id?: ID_Input;
  stateMachineSchema?: StateMachineSchemaCreateOneWithoutSMTransitionsInput;
  to: String;
}

export interface BusinessObjectUpdateWithoutOwnsDiagramsDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export interface BusinessObjectCreateOneWithoutBizAttributesInput {
  create?: BusinessObjectCreateWithoutBizAttributesInput;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface BusinessObjectUpsertWithoutOwnsDiagramsInput {
  update: BusinessObjectUpdateWithoutOwnsDiagramsDataInput;
  create: BusinessObjectCreateWithoutOwnsDiagramsInput;
}

export interface BusinessObjectCreateOneWithoutOutgoingRelationsInput {
  create?: BusinessObjectCreateWithoutOutgoingRelationsInput;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface DiagramUpsertWithWhereUniqueWithoutParticipatingBOsInput {
  where: DiagramWhereUniqueInput;
  update: DiagramUpdateWithoutParticipatingBOsDataInput;
  create: DiagramCreateWithoutParticipatingBOsInput;
}

export interface MetaAttributeCreateOneWithoutBizAttributesInput {
  create?: MetaAttributeCreateWithoutBizAttributesInput;
  connect?: MetaAttributeWhereUniqueInput;
}

export interface DiagramScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: DiagramScalarWhereInput[] | DiagramScalarWhereInput;
  OR?: DiagramScalarWhereInput[] | DiagramScalarWhereInput;
  NOT?: DiagramScalarWhereInput[] | DiagramScalarWhereInput;
}

export interface BusinessObjectCreateManyWithoutMetaObjectInput {
  create?:
    | BusinessObjectCreateWithoutMetaObjectInput[]
    | BusinessObjectCreateWithoutMetaObjectInput;
  connect?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
}

export interface DiagramUpdateManyWithWhereNestedInput {
  where: DiagramScalarWhereInput;
  data: DiagramUpdateManyDataInput;
}

export interface MetaRelationCreateOneWithoutBizRelationsInput {
  create?: MetaRelationCreateWithoutBizRelationsInput;
  connect?: MetaRelationWhereUniqueInput;
}

export interface DiagramUpdateManyDataInput {
  diagramData?: Json;
}

export interface MetaAttributeCreateManyWithoutObjectsInput {
  create?:
    | MetaAttributeCreateWithoutObjectsInput[]
    | MetaAttributeCreateWithoutObjectsInput;
  connect?: MetaAttributeWhereUniqueInput[] | MetaAttributeWhereUniqueInput;
}

export interface BusinessObjectUpsertWithoutPlanInput {
  update: BusinessObjectUpdateWithoutPlanDataInput;
  create: BusinessObjectCreateWithoutPlanInput;
}

export interface MetaRelationCreateManyWithoutOppositeObjectInput {
  create?:
    | MetaRelationCreateWithoutOppositeObjectInput[]
    | MetaRelationCreateWithoutOppositeObjectInput;
  connect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
}

export interface PlanUpsertWithoutItemBOsInput {
  update: PlanUpdateWithoutItemBOsDataInput;
  create: PlanCreateWithoutItemBOsInput;
}

export interface BusinessObjectCreateOneWithoutIncomingRelationsInput {
  create?: BusinessObjectCreateWithoutIncomingRelationsInput;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface BusinessObjectUpsertWithWhereUniqueWithoutParticipatesInDiagramsInput {
  where: BusinessObjectWhereUniqueInput;
  update: BusinessObjectUpdateWithoutParticipatesInDiagramsDataInput;
  create: BusinessObjectCreateWithoutParticipatesInDiagramsInput;
}

export interface MetaRelationCreateManyWithoutIncomingObjectInput {
  create?:
    | MetaRelationCreateWithoutIncomingObjectInput[]
    | MetaRelationCreateWithoutIncomingObjectInput;
  connect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
}

export interface BusinessObjectScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BusinessObjectScalarWhereInput[] | BusinessObjectScalarWhereInput;
  OR?: BusinessObjectScalarWhereInput[] | BusinessObjectScalarWhereInput;
  NOT?: BusinessObjectScalarWhereInput[] | BusinessObjectScalarWhereInput;
}

export interface PlanConfigCreateOneWithoutUiMoPlanInput {
  create?: PlanConfigCreateWithoutUiMoPlanInput;
  connect?: PlanConfigWhereUniqueInput;
}

export interface BusinessObjectUpdateManyWithWhereNestedInput {
  where: BusinessObjectScalarWhereInput;
  data: BusinessObjectUpdateManyDataInput;
}

export interface MetaRelationCreateOneWithoutOppositeRelationInput {
  create?: MetaRelationCreateWithoutOppositeRelationInput;
  connect?: MetaRelationWhereUniqueInput;
}

export interface BusinessObjectUpdateManyDataInput {
  name?: String;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
}

export interface MetaRelationCreateOneInput {
  create?: MetaRelationCreateInput;
  connect?: MetaRelationWhereUniqueInput;
}

export interface DiagramUpsertWithWhereUniqueWithoutOwnerBOInput {
  where: DiagramWhereUniqueInput;
  update: DiagramUpdateWithoutOwnerBODataInput;
  create: DiagramCreateWithoutOwnerBOInput;
}

export interface RenderColumnCreateInput {
  id?: ID_Input;
  widgets?: WidgetCreateManyInput;
  width?: Int;
}

export interface BusinessObjectUpsertWithWhereUniqueWithoutPlannedInInput {
  where: BusinessObjectWhereUniqueInput;
  update: BusinessObjectUpdateWithoutPlannedInDataInput;
  create: BusinessObjectCreateWithoutPlannedInInput;
}

export interface PlanCreateOneWithoutPlanBOInput {
  create?: PlanCreateWithoutPlanBOInput;
  connect?: PlanWhereUniqueInput;
}

export interface PlanUpsertWithoutPlanBOInput {
  update: PlanUpdateWithoutPlanBODataInput;
  create: PlanCreateWithoutPlanBOInput;
}

export interface DiagramCreateManyWithoutOwnerBOInput {
  create?:
    | DiagramCreateWithoutOwnerBOInput[]
    | DiagramCreateWithoutOwnerBOInput;
  connect?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
}

export interface BusinessObjectUpsertWithoutIncomingRelationsInput {
  update: BusinessObjectUpdateWithoutIncomingRelationsDataInput;
  create: BusinessObjectCreateWithoutIncomingRelationsInput;
}

export interface PlanCreateOneWithoutItemBOsInput {
  create?: PlanCreateWithoutItemBOsInput;
  connect?: PlanWhereUniqueInput;
}

export interface BizRelationUpdateOneWithoutOppositeRelationInput {
  create?: BizRelationCreateWithoutOppositeRelationInput;
  update?: BizRelationUpdateWithoutOppositeRelationDataInput;
  upsert?: BizRelationUpsertWithoutOppositeRelationInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BizRelationWhereUniqueInput;
}

export interface DiagramCreateManyWithoutParticipatingBOsInput {
  create?:
    | DiagramCreateWithoutParticipatingBOsInput[]
    | DiagramCreateWithoutParticipatingBOsInput;
  connect?: DiagramWhereUniqueInput[] | DiagramWhereUniqueInput;
}

export interface BizRelationUpdateWithoutOppositeRelationDataInput {
  incomingObject?: BusinessObjectUpdateOneWithoutOutgoingRelationsInput;
  metaRelation?: MetaRelationUpdateOneWithoutBizRelationsInput;
  oppositeObject?: BusinessObjectUpdateOneWithoutIncomingRelationsInput;
}

export interface RenderColumnWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  widgets_every?: WidgetWhereInput;
  widgets_some?: WidgetWhereInput;
  widgets_none?: WidgetWhereInput;
  width?: Int;
  width_not?: Int;
  width_in?: Int[] | Int;
  width_not_in?: Int[] | Int;
  width_lt?: Int;
  width_lte?: Int;
  width_gt?: Int;
  width_gte?: Int;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: RenderColumnWhereInput[] | RenderColumnWhereInput;
  OR?: RenderColumnWhereInput[] | RenderColumnWhereInput;
  NOT?: RenderColumnWhereInput[] | RenderColumnWhereInput;
}

export interface BizRelationUpsertWithoutOppositeRelationInput {
  update: BizRelationUpdateWithoutOppositeRelationDataInput;
  create: BizRelationCreateWithoutOppositeRelationInput;
}

export interface SMTransitionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SMTransitionWhereInput;
  AND?:
    | SMTransitionSubscriptionWhereInput[]
    | SMTransitionSubscriptionWhereInput;
  OR?:
    | SMTransitionSubscriptionWhereInput[]
    | SMTransitionSubscriptionWhereInput;
  NOT?:
    | SMTransitionSubscriptionWhereInput[]
    | SMTransitionSubscriptionWhereInput;
}

export interface BizRelationUpsertWithWhereUniqueWithoutMetaRelationInput {
  where: BizRelationWhereUniqueInput;
  update: BizRelationUpdateWithoutMetaRelationDataInput;
  create: BizRelationCreateWithoutMetaRelationInput;
}

export interface DiagramSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DiagramWhereInput;
  AND?: DiagramSubscriptionWhereInput[] | DiagramSubscriptionWhereInput;
  OR?: DiagramSubscriptionWhereInput[] | DiagramSubscriptionWhereInput;
  NOT?: DiagramSubscriptionWhereInput[] | DiagramSubscriptionWhereInput;
}

export interface BizRelationScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BizRelationScalarWhereInput[] | BizRelationScalarWhereInput;
  OR?: BizRelationScalarWhereInput[] | BizRelationScalarWhereInput;
  NOT?: BizRelationScalarWhereInput[] | BizRelationScalarWhereInput;
}

export interface UserUpdateManyMutationInput {
  userid?: String;
  password?: String;
  name?: String;
}

export interface MetaRelationUpsertWithWhereUniqueWithoutOppositeObjectInput {
  where: MetaRelationWhereUniqueInput;
  update: MetaRelationUpdateWithoutOppositeObjectDataInput;
  create: MetaRelationCreateWithoutOppositeObjectInput;
}

export interface TemplateMappingUpdateInput {
  template?: TemplateUpdateOneInput;
  businessObject?: BusinessObjectUpdateOneInput;
}

export interface MetaObjectUpsertWithoutOutgoingRelationsInput {
  update: MetaObjectUpdateWithoutOutgoingRelationsDataInput;
  create: MetaObjectCreateWithoutOutgoingRelationsInput;
}

export interface TemplateUpdateInput {
  name?: String;
  renderColumns?: RenderColumnUpdateManyInput;
}

export interface MetaRelationUpsertWithoutBizRelationsInput {
  update: MetaRelationUpdateWithoutBizRelationsDataInput;
  create: MetaRelationCreateWithoutBizRelationsInput;
}

export interface TemplateConfigUpdateDataInput {
  moObject?: MetaObjectUpdateOneWithoutTemplateConfigInput;
  moRelation?: MetaRelationUpdateOneInput;
  userRelatedMRId?: String;
  defaultTemplate?: TemplateUpdateOneInput;
}

export interface BizRelationUpsertWithWhereUniqueWithoutIncomingObjectInput {
  where: BizRelationWhereUniqueInput;
  update: BizRelationUpdateWithoutIncomingObjectDataInput;
  create: BizRelationCreateWithoutIncomingObjectInput;
}

export interface MetaObjectUpdateDataInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export interface BusinessObjectUpsertWithWhereUniqueWithoutMetaObjectInput {
  where: BusinessObjectWhereUniqueInput;
  update: BusinessObjectUpdateWithoutMetaObjectDataInput;
  create: BusinessObjectCreateWithoutMetaObjectInput;
}

export type StateMachineSchemaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface MetaObjectUpsertWithWhereUniqueWithoutAttributesInput {
  where: MetaObjectWhereUniqueInput;
  update: MetaObjectUpdateWithoutAttributesDataInput;
  create: MetaObjectCreateWithoutAttributesInput;
}

export interface BizRelationWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  incomingObject?: BusinessObjectWhereInput;
  metaRelation?: MetaRelationWhereInput;
  oppositeObject?: BusinessObjectWhereInput;
  oppositeRelation?: BizRelationWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: BizRelationWhereInput[] | BizRelationWhereInput;
  OR?: BizRelationWhereInput[] | BizRelationWhereInput;
  NOT?: BizRelationWhereInput[] | BizRelationWhereInput;
}

export interface MetaObjectScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: MetaObjectScalarWhereInput[] | MetaObjectScalarWhereInput;
  OR?: MetaObjectScalarWhereInput[] | MetaObjectScalarWhereInput;
  NOT?: MetaObjectScalarWhereInput[] | MetaObjectScalarWhereInput;
}

export interface SMTransitionUpdateWithoutStateMachineSchemaDataInput {
  event?: String;
  from?: String;
  to?: String;
}

export interface MetaObjectUpdateManyWithWhereNestedInput {
  where: MetaObjectScalarWhereInput;
  data: MetaObjectUpdateManyDataInput;
}

export interface TemplateMappingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  template?: TemplateWhereInput;
  businessObject?: BusinessObjectWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TemplateMappingWhereInput[] | TemplateMappingWhereInput;
  OR?: TemplateMappingWhereInput[] | TemplateMappingWhereInput;
  NOT?: TemplateMappingWhereInput[] | TemplateMappingWhereInput;
}

export interface MetaObjectUpdateManyDataInput {
  name?: String;
}

export interface StateMachineSchemaUpdateWithoutSMTransitionsDataInput {
  finalState?: String;
  initialState?: String;
  name?: String;
}

export interface MetaAttributeUpsertWithoutBizAttributesInput {
  update: MetaAttributeUpdateWithoutBizAttributesDataInput;
  create: MetaAttributeCreateWithoutBizAttributesInput;
}

export interface BizAttributeCreateManyWithoutBusinessObjectInput {
  create?:
    | BizAttributeCreateWithoutBusinessObjectInput[]
    | BizAttributeCreateWithoutBusinessObjectInput;
  connect?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
}

export interface BizAttributeUpsertWithWhereUniqueWithoutBusinessObjectInput {
  where: BizAttributeWhereUniqueInput;
  update: BizAttributeUpdateWithoutBusinessObjectDataInput;
  create: BizAttributeCreateWithoutBusinessObjectInput;
}

export interface BizRelationCreateManyWithoutIncomingObjectInput {
  create?:
    | BizRelationCreateWithoutIncomingObjectInput[]
    | BizRelationCreateWithoutIncomingObjectInput;
  connect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
}

export interface BusinessObjectUpsertWithoutOutgoingRelationsInput {
  update: BusinessObjectUpdateWithoutOutgoingRelationsDataInput;
  create: BusinessObjectCreateWithoutOutgoingRelationsInput;
}

export interface BizAttributeCreateManyWithoutMetaAttributeInput {
  create?:
    | BizAttributeCreateWithoutMetaAttributeInput[]
    | BizAttributeCreateWithoutMetaAttributeInput;
  connect?: BizAttributeWhereUniqueInput[] | BizAttributeWhereUniqueInput;
}

export interface BizRelationUpsertWithWhereUniqueWithoutOppositeObjectInput {
  where: BizRelationWhereUniqueInput;
  update: BizRelationUpdateWithoutOppositeObjectDataInput;
  create: BizRelationCreateWithoutOppositeObjectInput;
}

export interface MetaObjectCreateOneWithoutBusinessObjectsInput {
  create?: MetaObjectCreateWithoutBusinessObjectsInput;
  connect?: MetaObjectWhereUniqueInput;
}

export interface BusinessObjectUpsertWithoutBizAttributesInput {
  update: BusinessObjectUpdateWithoutBizAttributesDataInput;
  create: BusinessObjectCreateWithoutBizAttributesInput;
}

export interface MetaRelationCreateManyInput {
  create?: MetaRelationCreateInput[] | MetaRelationCreateInput;
  connect?: MetaRelationWhereUniqueInput[] | MetaRelationWhereUniqueInput;
}

export interface BizAttributeUpdateManyMutationInput {
  value?: String;
}

export interface TemplateCreateInput {
  id?: ID_Input;
  name?: String;
  renderColumns?: RenderColumnCreateManyInput;
}

export interface MetaObjectUpdateOneWithoutPlanConfigInput {
  create?: MetaObjectCreateWithoutPlanConfigInput;
  update?: MetaObjectUpdateWithoutPlanConfigDataInput;
  upsert?: MetaObjectUpsertWithoutPlanConfigInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MetaObjectWhereUniqueInput;
}

export interface BusinessObjectCreateManyWithoutPlannedInInput {
  create?:
    | BusinessObjectCreateWithoutPlannedInInput[]
    | BusinessObjectCreateWithoutPlannedInInput;
  connect?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
}

export interface PlanConfigUpdateInput {
  uiMoPlan?: MetaObjectUpdateOneWithoutPlanConfigInput;
  uiMoRelations?: MetaRelationUpdateManyInput;
}

export interface BusinessObjectCreateOneWithoutPlanInput {
  create?: BusinessObjectCreateWithoutPlanInput;
  connect?: BusinessObjectWhereUniqueInput;
}

export interface BizRelationCreateInput {
  id?: ID_Input;
  incomingObject?: BusinessObjectCreateOneWithoutOutgoingRelationsInput;
  metaRelation?: MetaRelationCreateOneWithoutBizRelationsInput;
  oppositeObject?: BusinessObjectCreateOneWithoutIncomingRelationsInput;
  oppositeRelation?: BizRelationCreateOneWithoutOppositeRelationInput;
}

export interface TemplateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  renderColumns_every?: RenderColumnWhereInput;
  renderColumns_some?: RenderColumnWhereInput;
  renderColumns_none?: RenderColumnWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: TemplateWhereInput[] | TemplateWhereInput;
  OR?: TemplateWhereInput[] | TemplateWhereInput;
  NOT?: TemplateWhereInput[] | TemplateWhereInput;
}

export interface BizRelationUpdateInput {
  incomingObject?: BusinessObjectUpdateOneWithoutOutgoingRelationsInput;
  metaRelation?: MetaRelationUpdateOneWithoutBizRelationsInput;
  oppositeObject?: BusinessObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: BizRelationUpdateOneWithoutOppositeRelationInput;
}

export interface BizAttributeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BizAttributeWhereInput;
  AND?:
    | BizAttributeSubscriptionWhereInput[]
    | BizAttributeSubscriptionWhereInput;
  OR?:
    | BizAttributeSubscriptionWhereInput[]
    | BizAttributeSubscriptionWhereInput;
  NOT?:
    | BizAttributeSubscriptionWhereInput[]
    | BizAttributeSubscriptionWhereInput;
}

export interface BusinessObjectCreateInput {
  bizAttributes?: BizAttributeCreateManyWithoutBusinessObjectInput;
  id?: ID_Input;
  incomingRelations?: BizRelationCreateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectCreateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationCreateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectCreatetagsInput;
  plan?: PlanCreateOneWithoutPlanBOInput;
  plannedIn?: PlanCreateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramCreateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramCreateManyWithoutParticipatingBOsInput;
}

export interface TemplateConfigUpdateManyMutationInput {
  userRelatedMRId?: String;
}

export interface BusinessObjectUpdateInput {
  bizAttributes?: BizAttributeUpdateManyWithoutBusinessObjectInput;
  incomingRelations?: BizRelationUpdateManyWithoutOppositeObjectInput;
  metaObject?: MetaObjectUpdateOneWithoutBusinessObjectsInput;
  name?: String;
  outgoingRelations?: BizRelationUpdateManyWithoutIncomingObjectInput;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
  plan?: PlanUpdateOneWithoutPlanBOInput;
  plannedIn?: PlanUpdateOneWithoutItemBOsInput;
  ownsDiagrams?: DiagramUpdateManyWithoutOwnerBOInput;
  participatesInDiagrams?: DiagramUpdateManyWithoutParticipatingBOsInput;
}

export interface MetaAttributeUpdateDataInput {
  bizAttributes?: BizAttributeUpdateManyWithoutMetaAttributeInput;
  name?: String;
  objects?: MetaObjectUpdateManyWithoutAttributesInput;
  type?: AttributeType;
}

export interface BusinessObjectUpdateManyMutationInput {
  name?: String;
  state?: String;
  tags?: BusinessObjectUpdatetagsInput;
}

export interface MetaAttributeCreateOneInput {
  create?: MetaAttributeCreateInput;
  connect?: MetaAttributeWhereUniqueInput;
}

export interface DiagramCreateInput {
  id?: ID_Input;
  diagramData?: Json;
  ownerBO?: BusinessObjectCreateOneWithoutOwnsDiagramsInput;
  participatingBOs?: BusinessObjectCreateManyWithoutParticipatesInDiagramsInput;
}

export interface SMTransitionUpdateManyWithoutStateMachineSchemaInput {
  create?:
    | SMTransitionCreateWithoutStateMachineSchemaInput[]
    | SMTransitionCreateWithoutStateMachineSchemaInput;
  delete?: SMTransitionWhereUniqueInput[] | SMTransitionWhereUniqueInput;
  connect?: SMTransitionWhereUniqueInput[] | SMTransitionWhereUniqueInput;
  set?: SMTransitionWhereUniqueInput[] | SMTransitionWhereUniqueInput;
  disconnect?: SMTransitionWhereUniqueInput[] | SMTransitionWhereUniqueInput;
  update?:
    | SMTransitionUpdateWithWhereUniqueWithoutStateMachineSchemaInput[]
    | SMTransitionUpdateWithWhereUniqueWithoutStateMachineSchemaInput;
  upsert?:
    | SMTransitionUpsertWithWhereUniqueWithoutStateMachineSchemaInput[]
    | SMTransitionUpsertWithWhereUniqueWithoutStateMachineSchemaInput;
  deleteMany?: SMTransitionScalarWhereInput[] | SMTransitionScalarWhereInput;
  updateMany?:
    | SMTransitionUpdateManyWithWhereNestedInput[]
    | SMTransitionUpdateManyWithWhereNestedInput;
}

export interface DiagramUpdateInput {
  diagramData?: Json;
  ownerBO?: BusinessObjectUpdateOneWithoutOwnsDiagramsInput;
  participatingBOs?: BusinessObjectUpdateManyWithoutParticipatesInDiagramsInput;
}

export type WidgetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DiagramUpdateManyMutationInput {
  diagramData?: Json;
}

export interface MetaObjectCreateManyWithoutAttributesInput {
  create?:
    | MetaObjectCreateWithoutAttributesInput[]
    | MetaObjectCreateWithoutAttributesInput;
  connect?: MetaObjectWhereUniqueInput[] | MetaObjectWhereUniqueInput;
}

export interface MetaAttributeCreateInput {
  bizAttributes?: BizAttributeCreateManyWithoutMetaAttributeInput;
  id?: ID_Input;
  name?: String;
  objects?: MetaObjectCreateManyWithoutAttributesInput;
  type?: AttributeType;
}

export interface BizRelationCreateManyWithoutMetaRelationInput {
  create?:
    | BizRelationCreateWithoutMetaRelationInput[]
    | BizRelationCreateWithoutMetaRelationInput;
  connect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
}

export interface MetaAttributeUpdateInput {
  bizAttributes?: BizAttributeUpdateManyWithoutMetaAttributeInput;
  name?: String;
  objects?: MetaObjectUpdateManyWithoutAttributesInput;
  type?: AttributeType;
}

export interface TemplateConfigCreateOneWithoutMoObjectInput {
  create?: TemplateConfigCreateWithoutMoObjectInput;
  connect?: TemplateConfigWhereUniqueInput;
}

export interface MetaAttributeUpdateManyMutationInput {
  name?: String;
  type?: AttributeType;
}

export interface BusinessObjectCreateManyWithoutParticipatesInDiagramsInput {
  create?:
    | BusinessObjectCreateWithoutParticipatesInDiagramsInput[]
    | BusinessObjectCreateWithoutParticipatesInDiagramsInput;
  connect?: BusinessObjectWhereUniqueInput[] | BusinessObjectWhereUniqueInput;
}

export interface MetaObjectCreateInput {
  attributes?: MetaAttributeCreateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectCreateManyWithoutMetaObjectInput;
  id?: ID_Input;
  incomingRelations?: MetaRelationCreateManyWithoutOppositeObjectInput;
  name: String;
  outgoingRelations?: MetaRelationCreateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigCreateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigCreateOneWithoutMoObjectInput;
}

export interface PlanSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlanWhereInput;
  AND?: PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput;
  OR?: PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput;
  NOT?: PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput;
}

export interface MetaObjectUpdateInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
  templateConfig?: TemplateConfigUpdateOneWithoutMoObjectInput;
}

export interface MetaObjectUpdateWithoutTemplateConfigDataInput {
  attributes?: MetaAttributeUpdateManyWithoutObjectsInput;
  businessObjects?: BusinessObjectUpdateManyWithoutMetaObjectInput;
  incomingRelations?: MetaRelationUpdateManyWithoutOppositeObjectInput;
  name?: String;
  outgoingRelations?: MetaRelationUpdateManyWithoutIncomingObjectInput;
  planConfig?: PlanConfigUpdateOneWithoutUiMoPlanInput;
}

export interface MetaObjectUpdateManyMutationInput {
  name?: String;
}

export type TemplateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MetaRelationUpdateInput {
  bizRelations?: BizRelationUpdateManyWithoutMetaRelationInput;
  incomingObject?: MetaObjectUpdateOneWithoutOutgoingRelationsInput;
  multiplicity?: MultiplicityType;
  oppositeName?: String;
  oppositeObject?: MetaObjectUpdateOneWithoutIncomingRelationsInput;
  oppositeRelation?: MetaRelationUpdateOneWithoutOppositeRelationInput;
}

export interface BizRelationCreateManyWithoutOppositeObjectInput {
  create?:
    | BizRelationCreateWithoutOppositeObjectInput[]
    | BizRelationCreateWithoutOppositeObjectInput;
  connect?: BizRelationWhereUniqueInput[] | BizRelationWhereUniqueInput;
}

export interface MetaRelationUpdateManyMutationInput {
  multiplicity?: MultiplicityType;
  oppositeName?: String;
}

export interface MetaObjectCreateOneWithoutIncomingRelationsInput {
  create?: MetaObjectCreateWithoutIncomingRelationsInput;
  connect?: MetaObjectWhereUniqueInput;
}

export interface PlanCreateInput {
  id?: ID_Input;
  planData?: Json;
  planBO?: BusinessObjectCreateOneWithoutPlanInput;
  itemBOs?: BusinessObjectCreateManyWithoutPlannedInInput;
}

export interface PlanWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  planBO?: BusinessObjectWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  itemBOs_every?: BusinessObjectWhereInput;
  itemBOs_some?: BusinessObjectWhereInput;
  itemBOs_none?: BusinessObjectWhereInput;
  AND?: PlanWhereInput[] | PlanWhereInput;
  OR?: PlanWhereInput[] | PlanWhereInput;
  NOT?: PlanWhereInput[] | PlanWhereInput;
}

export interface MetaObjectCreateOneWithoutPlanConfigInput {
  create?: MetaObjectCreateWithoutPlanConfigInput;
  connect?: MetaObjectWhereUniqueInput;
}

export interface PlanConfigCreateInput {
  id?: ID_Input;
  uiMoPlan?: MetaObjectCreateOneWithoutPlanConfigInput;
  uiMoRelations?: MetaRelationCreateManyInput;
}

export interface PlanUpdateManyMutationInput {
  planData?: Json;
}

export interface PlanUpdateInput {
  planData?: Json;
  planBO?: BusinessObjectUpdateOneWithoutPlanInput;
  itemBOs?: BusinessObjectUpdateManyWithoutPlannedInInput;
}

export interface BusinessObjectUpsertNestedInput {
  update: BusinessObjectUpdateDataInput;
  create: BusinessObjectCreateInput;
}

export interface WidgetCreateInput {
  id?: ID_Input;
  name?: String;
  type: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
}

export interface MetaObjectCreateOneWithoutOutgoingRelationsInput {
  create?: MetaObjectCreateWithoutOutgoingRelationsInput;
  connect?: MetaObjectWhereUniqueInput;
}

export interface SMTransitionUpdateManyMutationInput {
  event?: String;
  from?: String;
  to?: String;
}

export interface MetaObjectWhereInput {
  attributes_every?: MetaAttributeWhereInput;
  attributes_some?: MetaAttributeWhereInput;
  attributes_none?: MetaAttributeWhereInput;
  businessObjects_every?: BusinessObjectWhereInput;
  businessObjects_some?: BusinessObjectWhereInput;
  businessObjects_none?: BusinessObjectWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  incomingRelations_every?: MetaRelationWhereInput;
  incomingRelations_some?: MetaRelationWhereInput;
  incomingRelations_none?: MetaRelationWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  outgoingRelations_every?: MetaRelationWhereInput;
  outgoingRelations_some?: MetaRelationWhereInput;
  outgoingRelations_none?: MetaRelationWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  planConfig?: PlanConfigWhereInput;
  templateConfig?: TemplateConfigWhereInput;
  AND?: MetaObjectWhereInput[] | MetaObjectWhereInput;
  OR?: MetaObjectWhereInput[] | MetaObjectWhereInput;
  NOT?: MetaObjectWhereInput[] | MetaObjectWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WidgetPreviousValues {
  id: ID_Output;
  name?: String;
  type: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WidgetPreviousValuesPromise
  extends Promise<WidgetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<WidgetType>;
  width: () => Promise<Int>;
  boid: () => Promise<String>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WidgetPreviousValuesSubscription
  extends Promise<AsyncIterator<WidgetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<WidgetType>>;
  width: () => Promise<AsyncIterator<Int>>;
  boid: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBusinessObject {
  count: Int;
}

export interface AggregateBusinessObjectPromise
  extends Promise<AggregateBusinessObject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBusinessObjectSubscription
  extends Promise<AsyncIterator<AggregateBusinessObject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetaRelation {
  createdAt: DateTimeOutput;
  id: ID_Output;
  multiplicity: MultiplicityType;
  oppositeName: String;
  updatedAt: DateTimeOutput;
}

export interface MetaRelationPromise
  extends Promise<MetaRelation>,
    Fragmentable {
  bizRelations: <T = FragmentableArray<BizRelation>>(args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  incomingObject: <T = MetaObjectPromise>() => T;
  multiplicity: () => Promise<MultiplicityType>;
  oppositeName: () => Promise<String>;
  oppositeObject: <T = MetaObjectPromise>() => T;
  oppositeRelation: <T = MetaRelationPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MetaRelationSubscription
  extends Promise<AsyncIterator<MetaRelation>>,
    Fragmentable {
  bizRelations: <T = Promise<AsyncIterator<BizRelationSubscription>>>(args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  incomingObject: <T = MetaObjectSubscription>() => T;
  multiplicity: () => Promise<AsyncIterator<MultiplicityType>>;
  oppositeName: () => Promise<AsyncIterator<String>>;
  oppositeObject: <T = MetaObjectSubscription>() => T;
  oppositeRelation: <T = MetaRelationSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BusinessObjectEdge {
  node: BusinessObject;
  cursor: String;
}

export interface BusinessObjectEdgePromise
  extends Promise<BusinessObjectEdge>,
    Fragmentable {
  node: <T = BusinessObjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BusinessObjectEdgeSubscription
  extends Promise<AsyncIterator<BusinessObjectEdge>>,
    Fragmentable {
  node: <T = BusinessObjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MetaObject {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface MetaObjectPromise extends Promise<MetaObject>, Fragmentable {
  attributes: <T = FragmentableArray<MetaAttribute>>(args?: {
    where?: MetaAttributeWhereInput;
    orderBy?: MetaAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessObjects: <T = FragmentableArray<BusinessObject>>(args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  incomingRelations: <T = FragmentableArray<MetaRelation>>(args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  outgoingRelations: <T = FragmentableArray<MetaRelation>>(args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  planConfig: <T = PlanConfigPromise>() => T;
  templateConfig: <T = TemplateConfigPromise>() => T;
}

export interface MetaObjectSubscription
  extends Promise<AsyncIterator<MetaObject>>,
    Fragmentable {
  attributes: <T = Promise<AsyncIterator<MetaAttributeSubscription>>>(args?: {
    where?: MetaAttributeWhereInput;
    orderBy?: MetaAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  businessObjects: <
    T = Promise<AsyncIterator<BusinessObjectSubscription>>
  >(args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  incomingRelations: <
    T = Promise<AsyncIterator<MetaRelationSubscription>>
  >(args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  outgoingRelations: <
    T = Promise<AsyncIterator<MetaRelationSubscription>>
  >(args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  planConfig: <T = PlanConfigSubscription>() => T;
  templateConfig: <T = TemplateConfigSubscription>() => T;
}

export interface DiagramConnection {
  pageInfo: PageInfo;
  edges: DiagramEdge[];
}

export interface DiagramConnectionPromise
  extends Promise<DiagramConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiagramEdge>>() => T;
  aggregate: <T = AggregateDiagramPromise>() => T;
}

export interface DiagramConnectionSubscription
  extends Promise<AsyncIterator<DiagramConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiagramEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiagramSubscription>() => T;
}

export interface TemplateMappingPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TemplateMappingPreviousValuesPromise
  extends Promise<TemplateMappingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TemplateMappingPreviousValuesSubscription
  extends Promise<AsyncIterator<TemplateMappingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BusinessObjectConnection {
  pageInfo: PageInfo;
  edges: BusinessObjectEdge[];
}

export interface BusinessObjectConnectionPromise
  extends Promise<BusinessObjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BusinessObjectEdge>>() => T;
  aggregate: <T = AggregateBusinessObjectPromise>() => T;
}

export interface BusinessObjectConnectionSubscription
  extends Promise<AsyncIterator<BusinessObjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BusinessObjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBusinessObjectSubscription>() => T;
}

export interface BizRelation {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
}

export interface BizRelationPromise extends Promise<BizRelation>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  incomingObject: <T = BusinessObjectPromise>() => T;
  metaRelation: <T = MetaRelationPromise>() => T;
  oppositeObject: <T = BusinessObjectPromise>() => T;
  oppositeRelation: <T = BizRelationPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BizRelationSubscription
  extends Promise<AsyncIterator<BizRelation>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  incomingObject: <T = BusinessObjectSubscription>() => T;
  metaRelation: <T = MetaRelationSubscription>() => T;
  oppositeObject: <T = BusinessObjectSubscription>() => T;
  oppositeRelation: <T = BizRelationSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WidgetConnection {
  pageInfo: PageInfo;
  edges: WidgetEdge[];
}

export interface WidgetConnectionPromise
  extends Promise<WidgetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WidgetEdge>>() => T;
  aggregate: <T = AggregateWidgetPromise>() => T;
}

export interface WidgetConnectionSubscription
  extends Promise<AsyncIterator<WidgetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WidgetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWidgetSubscription>() => T;
}

export interface AggregateWidget {
  count: Int;
}

export interface AggregateWidgetPromise
  extends Promise<AggregateWidget>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWidgetSubscription
  extends Promise<AsyncIterator<AggregateWidget>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBizRelation {
  count: Int;
}

export interface AggregateBizRelationPromise
  extends Promise<AggregateBizRelation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBizRelationSubscription
  extends Promise<AsyncIterator<AggregateBizRelation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BusinessObject {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name?: String;
  state?: String;
  tags: String[];
  updatedAt: DateTimeOutput;
}

export interface BusinessObjectPromise
  extends Promise<BusinessObject>,
    Fragmentable {
  bizAttributes: <T = FragmentableArray<BizAttribute>>(args?: {
    where?: BizAttributeWhereInput;
    orderBy?: BizAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  incomingRelations: <T = FragmentableArray<BizRelation>>(args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metaObject: <T = MetaObjectPromise>() => T;
  name: () => Promise<String>;
  outgoingRelations: <T = FragmentableArray<BizRelation>>(args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  state: () => Promise<String>;
  tags: () => Promise<String[]>;
  updatedAt: () => Promise<DateTimeOutput>;
  plan: <T = PlanPromise>() => T;
  plannedIn: <T = PlanPromise>() => T;
  ownsDiagrams: <T = FragmentableArray<Diagram>>(args?: {
    where?: DiagramWhereInput;
    orderBy?: DiagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participatesInDiagrams: <T = FragmentableArray<Diagram>>(args?: {
    where?: DiagramWhereInput;
    orderBy?: DiagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BusinessObjectSubscription
  extends Promise<AsyncIterator<BusinessObject>>,
    Fragmentable {
  bizAttributes: <T = Promise<AsyncIterator<BizAttributeSubscription>>>(args?: {
    where?: BizAttributeWhereInput;
    orderBy?: BizAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  incomingRelations: <
    T = Promise<AsyncIterator<BizRelationSubscription>>
  >(args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  metaObject: <T = MetaObjectSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  outgoingRelations: <
    T = Promise<AsyncIterator<BizRelationSubscription>>
  >(args?: {
    where?: BizRelationWhereInput;
    orderBy?: BizRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  state: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  plan: <T = PlanSubscription>() => T;
  plannedIn: <T = PlanSubscription>() => T;
  ownsDiagrams: <T = Promise<AsyncIterator<DiagramSubscription>>>(args?: {
    where?: DiagramWhereInput;
    orderBy?: DiagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participatesInDiagrams: <
    T = Promise<AsyncIterator<DiagramSubscription>>
  >(args?: {
    where?: DiagramWhereInput;
    orderBy?: DiagramOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BizAttribute {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  value: String;
}

export interface BizAttributePromise
  extends Promise<BizAttribute>,
    Fragmentable {
  businessObject: <T = BusinessObjectPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  metaAttribute: <T = MetaAttributePromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface BizAttributeSubscription
  extends Promise<AsyncIterator<BizAttribute>>,
    Fragmentable {
  businessObject: <T = BusinessObjectSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  metaAttribute: <T = MetaAttributeSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTemplateMapping {
  count: Int;
}

export interface AggregateTemplateMappingPromise
  extends Promise<AggregateTemplateMapping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTemplateMappingSubscription
  extends Promise<AsyncIterator<AggregateTemplateMapping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BizAttributeSubscriptionPayload {
  mutation: MutationType;
  node: BizAttribute;
  updatedFields: String[];
  previousValues: BizAttributePreviousValues;
}

export interface BizAttributeSubscriptionPayloadPromise
  extends Promise<BizAttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BizAttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BizAttributePreviousValuesPromise>() => T;
}

export interface BizAttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BizAttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BizAttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BizAttributePreviousValuesSubscription>() => T;
}

export interface TemplateMappingConnection {
  pageInfo: PageInfo;
  edges: TemplateMappingEdge[];
}

export interface TemplateMappingConnectionPromise
  extends Promise<TemplateMappingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TemplateMappingEdge>>() => T;
  aggregate: <T = AggregateTemplateMappingPromise>() => T;
}

export interface TemplateMappingConnectionSubscription
  extends Promise<AsyncIterator<TemplateMappingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TemplateMappingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTemplateMappingSubscription>() => T;
}

export interface BizAttributePreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  value: String;
}

export interface BizAttributePreviousValuesPromise
  extends Promise<BizAttributePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface BizAttributePreviousValuesSubscription
  extends Promise<AsyncIterator<BizAttributePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTemplateConfig {
  count: Int;
}

export interface AggregateTemplateConfigPromise
  extends Promise<AggregateTemplateConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTemplateConfigSubscription
  extends Promise<AsyncIterator<AggregateTemplateConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BizRelationEdge {
  node: BizRelation;
  cursor: String;
}

export interface BizRelationEdgePromise
  extends Promise<BizRelationEdge>,
    Fragmentable {
  node: <T = BizRelationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BizRelationEdgeSubscription
  extends Promise<AsyncIterator<BizRelationEdge>>,
    Fragmentable {
  node: <T = BizRelationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TemplateConfigConnection {
  pageInfo: PageInfo;
  edges: TemplateConfigEdge[];
}

export interface TemplateConfigConnectionPromise
  extends Promise<TemplateConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TemplateConfigEdge>>() => T;
  aggregate: <T = AggregateTemplateConfigPromise>() => T;
}

export interface TemplateConfigConnectionSubscription
  extends Promise<AsyncIterator<TemplateConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TemplateConfigEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTemplateConfigSubscription>() => T;
}

export interface BizRelationSubscriptionPayload {
  mutation: MutationType;
  node: BizRelation;
  updatedFields: String[];
  previousValues: BizRelationPreviousValues;
}

export interface BizRelationSubscriptionPayloadPromise
  extends Promise<BizRelationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BizRelationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BizRelationPreviousValuesPromise>() => T;
}

export interface BizRelationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BizRelationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BizRelationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BizRelationPreviousValuesSubscription>() => T;
}

export interface TemplateEdge {
  node: Template;
  cursor: String;
}

export interface TemplateEdgePromise
  extends Promise<TemplateEdge>,
    Fragmentable {
  node: <T = TemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TemplateEdgeSubscription
  extends Promise<AsyncIterator<TemplateEdge>>,
    Fragmentable {
  node: <T = TemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BizRelationPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
}

export interface BizRelationPreviousValuesPromise
  extends Promise<BizRelationPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BizRelationPreviousValuesSubscription
  extends Promise<AsyncIterator<BizRelationPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WidgetSubscriptionPayload {
  mutation: MutationType;
  node: Widget;
  updatedFields: String[];
  previousValues: WidgetPreviousValues;
}

export interface WidgetSubscriptionPayloadPromise
  extends Promise<WidgetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WidgetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WidgetPreviousValuesPromise>() => T;
}

export interface WidgetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WidgetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WidgetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WidgetPreviousValuesSubscription>() => T;
}

export interface BizRelationConnection {
  pageInfo: PageInfo;
  edges: BizRelationEdge[];
}

export interface BizRelationConnectionPromise
  extends Promise<BizRelationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BizRelationEdge>>() => T;
  aggregate: <T = AggregateBizRelationPromise>() => T;
}

export interface BizRelationConnectionSubscription
  extends Promise<AsyncIterator<BizRelationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BizRelationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBizRelationSubscription>() => T;
}

export interface SystemSetupEdge {
  node: SystemSetup;
  cursor: String;
}

export interface SystemSetupEdgePromise
  extends Promise<SystemSetupEdge>,
    Fragmentable {
  node: <T = SystemSetupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SystemSetupEdgeSubscription
  extends Promise<AsyncIterator<SystemSetupEdge>>,
    Fragmentable {
  node: <T = SystemSetupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BusinessObjectSubscriptionPayload {
  mutation: MutationType;
  node: BusinessObject;
  updatedFields: String[];
  previousValues: BusinessObjectPreviousValues;
}

export interface BusinessObjectSubscriptionPayloadPromise
  extends Promise<BusinessObjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BusinessObjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BusinessObjectPreviousValuesPromise>() => T;
}

export interface BusinessObjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BusinessObjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BusinessObjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BusinessObjectPreviousValuesSubscription>() => T;
}

export interface SystemSetup {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SystemSetupPromise extends Promise<SystemSetup>, Fragmentable {
  id: () => Promise<ID_Output>;
  systemUserMOMapping: <T = MetaObjectPromise>() => T;
  systemUseridMAMapping: <T = MetaAttributePromise>() => T;
  templateConfig: <T = TemplateConfigPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SystemSetupSubscription
  extends Promise<AsyncIterator<SystemSetup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  systemUserMOMapping: <T = MetaObjectSubscription>() => T;
  systemUseridMAMapping: <T = MetaAttributeSubscription>() => T;
  templateConfig: <T = TemplateConfigSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BusinessObjectPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name?: String;
  state?: String;
  tags: String[];
  updatedAt: DateTimeOutput;
}

export interface BusinessObjectPreviousValuesPromise
  extends Promise<BusinessObjectPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  state: () => Promise<String>;
  tags: () => Promise<String[]>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BusinessObjectPreviousValuesSubscription
  extends Promise<AsyncIterator<BusinessObjectPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StateMachineSchemaEdge {
  node: StateMachineSchema;
  cursor: String;
}

export interface StateMachineSchemaEdgePromise
  extends Promise<StateMachineSchemaEdge>,
    Fragmentable {
  node: <T = StateMachineSchemaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StateMachineSchemaEdgeSubscription
  extends Promise<AsyncIterator<StateMachineSchemaEdge>>,
    Fragmentable {
  node: <T = StateMachineSchemaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBizAttribute {
  count: Int;
}

export interface AggregateBizAttributePromise
  extends Promise<AggregateBizAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBizAttributeSubscription
  extends Promise<AsyncIterator<AggregateBizAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSMTransition {
  count: Int;
}

export interface AggregateSMTransitionPromise
  extends Promise<AggregateSMTransition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSMTransitionSubscription
  extends Promise<AsyncIterator<AggregateSMTransition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DiagramSubscriptionPayload {
  mutation: MutationType;
  node: Diagram;
  updatedFields: String[];
  previousValues: DiagramPreviousValues;
}

export interface DiagramSubscriptionPayloadPromise
  extends Promise<DiagramSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiagramPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiagramPreviousValuesPromise>() => T;
}

export interface DiagramSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiagramSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiagramSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiagramPreviousValuesSubscription>() => T;
}

export interface SMTransitionConnection {
  pageInfo: PageInfo;
  edges: SMTransitionEdge[];
}

export interface SMTransitionConnectionPromise
  extends Promise<SMTransitionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SMTransitionEdge>>() => T;
  aggregate: <T = AggregateSMTransitionPromise>() => T;
}

export interface SMTransitionConnectionSubscription
  extends Promise<AsyncIterator<SMTransitionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SMTransitionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSMTransitionSubscription>() => T;
}

export interface DiagramPreviousValues {
  id: ID_Output;
  diagramData?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiagramPreviousValuesPromise
  extends Promise<DiagramPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  diagramData: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DiagramPreviousValuesSubscription
  extends Promise<AsyncIterator<DiagramPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  diagramData: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SMTransition {
  createdAt: DateTimeOutput;
  event: String;
  from: String;
  id: ID_Output;
  to: String;
  updatedAt: DateTimeOutput;
}

export interface SMTransitionPromise
  extends Promise<SMTransition>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  event: () => Promise<String>;
  from: () => Promise<String>;
  id: () => Promise<ID_Output>;
  stateMachineSchema: <T = StateMachineSchemaPromise>() => T;
  to: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SMTransitionSubscription
  extends Promise<AsyncIterator<SMTransition>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: () => Promise<AsyncIterator<String>>;
  from: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  stateMachineSchema: <T = StateMachineSchemaSubscription>() => T;
  to: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BizAttributeEdge {
  node: BizAttribute;
  cursor: String;
}

export interface BizAttributeEdgePromise
  extends Promise<BizAttributeEdge>,
    Fragmentable {
  node: <T = BizAttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BizAttributeEdgeSubscription
  extends Promise<AsyncIterator<BizAttributeEdge>>,
    Fragmentable {
  node: <T = BizAttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RenderColumnEdge {
  node: RenderColumn;
  cursor: String;
}

export interface RenderColumnEdgePromise
  extends Promise<RenderColumnEdge>,
    Fragmentable {
  node: <T = RenderColumnPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RenderColumnEdgeSubscription
  extends Promise<AsyncIterator<RenderColumnEdge>>,
    Fragmentable {
  node: <T = RenderColumnSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MetaAttributeSubscriptionPayload {
  mutation: MutationType;
  node: MetaAttribute;
  updatedFields: String[];
  previousValues: MetaAttributePreviousValues;
}

export interface MetaAttributeSubscriptionPayloadPromise
  extends Promise<MetaAttributeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MetaAttributePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MetaAttributePreviousValuesPromise>() => T;
}

export interface MetaAttributeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MetaAttributeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MetaAttributeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MetaAttributePreviousValuesSubscription>() => T;
}

export interface AggregatePlanConfig {
  count: Int;
}

export interface AggregatePlanConfigPromise
  extends Promise<AggregatePlanConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlanConfigSubscription
  extends Promise<AsyncIterator<AggregatePlanConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetaAttributePreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name?: String;
  type?: AttributeType;
  updatedAt: DateTimeOutput;
}

export interface MetaAttributePreviousValuesPromise
  extends Promise<MetaAttributePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<AttributeType>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MetaAttributePreviousValuesSubscription
  extends Promise<AsyncIterator<MetaAttributePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<AttributeType>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanConfigConnection {
  pageInfo: PageInfo;
  edges: PlanConfigEdge[];
}

export interface PlanConfigConnectionPromise
  extends Promise<PlanConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlanConfigEdge>>() => T;
  aggregate: <T = AggregatePlanConfigPromise>() => T;
}

export interface PlanConfigConnectionSubscription
  extends Promise<AsyncIterator<PlanConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlanConfigEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlanConfigSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  userid?: String;
  password?: String;
  name?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userid: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userid: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanEdge {
  node: Plan;
  cursor: String;
}

export interface PlanEdgePromise extends Promise<PlanEdge>, Fragmentable {
  node: <T = PlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlanEdgeSubscription
  extends Promise<AsyncIterator<PlanEdge>>,
    Fragmentable {
  node: <T = PlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MetaObjectSubscriptionPayload {
  mutation: MutationType;
  node: MetaObject;
  updatedFields: String[];
  previousValues: MetaObjectPreviousValues;
}

export interface MetaObjectSubscriptionPayloadPromise
  extends Promise<MetaObjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MetaObjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MetaObjectPreviousValuesPromise>() => T;
}

export interface MetaObjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MetaObjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MetaObjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MetaObjectPreviousValuesSubscription>() => T;
}

export interface MetaAttribute {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name?: String;
  type?: AttributeType;
  updatedAt: DateTimeOutput;
}

export interface MetaAttributePromise
  extends Promise<MetaAttribute>,
    Fragmentable {
  bizAttributes: <T = FragmentableArray<BizAttribute>>(args?: {
    where?: BizAttributeWhereInput;
    orderBy?: BizAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  objects: <T = FragmentableArray<MetaObject>>(args?: {
    where?: MetaObjectWhereInput;
    orderBy?: MetaObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<AttributeType>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MetaAttributeSubscription
  extends Promise<AsyncIterator<MetaAttribute>>,
    Fragmentable {
  bizAttributes: <T = Promise<AsyncIterator<BizAttributeSubscription>>>(args?: {
    where?: BizAttributeWhereInput;
    orderBy?: BizAttributeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  objects: <T = Promise<AsyncIterator<MetaObjectSubscription>>>(args?: {
    where?: MetaObjectWhereInput;
    orderBy?: MetaObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<AsyncIterator<AttributeType>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MetaObjectPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface MetaObjectPreviousValuesPromise
  extends Promise<MetaObjectPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MetaObjectPreviousValuesSubscription
  extends Promise<AsyncIterator<MetaObjectPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MetaRelationEdge {
  node: MetaRelation;
  cursor: String;
}

export interface MetaRelationEdgePromise
  extends Promise<MetaRelationEdge>,
    Fragmentable {
  node: <T = MetaRelationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MetaRelationEdgeSubscription
  extends Promise<AsyncIterator<MetaRelationEdge>>,
    Fragmentable {
  node: <T = MetaRelationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMetaObject {
  count: Int;
}

export interface AggregateMetaObjectPromise
  extends Promise<AggregateMetaObject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMetaObjectSubscription
  extends Promise<AsyncIterator<AggregateMetaObject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetaRelationSubscriptionPayload {
  mutation: MutationType;
  node: MetaRelation;
  updatedFields: String[];
  previousValues: MetaRelationPreviousValues;
}

export interface MetaRelationSubscriptionPayloadPromise
  extends Promise<MetaRelationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MetaRelationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MetaRelationPreviousValuesPromise>() => T;
}

export interface MetaRelationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MetaRelationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MetaRelationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MetaRelationPreviousValuesSubscription>() => T;
}

export interface MetaObjectConnection {
  pageInfo: PageInfo;
  edges: MetaObjectEdge[];
}

export interface MetaObjectConnectionPromise
  extends Promise<MetaObjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MetaObjectEdge>>() => T;
  aggregate: <T = AggregateMetaObjectPromise>() => T;
}

export interface MetaObjectConnectionSubscription
  extends Promise<AsyncIterator<MetaObjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MetaObjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMetaObjectSubscription>() => T;
}

export interface MetaRelationPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  multiplicity: MultiplicityType;
  oppositeName: String;
  updatedAt: DateTimeOutput;
}

export interface MetaRelationPreviousValuesPromise
  extends Promise<MetaRelationPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  multiplicity: () => Promise<MultiplicityType>;
  oppositeName: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MetaRelationPreviousValuesSubscription
  extends Promise<AsyncIterator<MetaRelationPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  multiplicity: () => Promise<AsyncIterator<MultiplicityType>>;
  oppositeName: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MetaAttributeEdge {
  node: MetaAttribute;
  cursor: String;
}

export interface MetaAttributeEdgePromise
  extends Promise<MetaAttributeEdge>,
    Fragmentable {
  node: <T = MetaAttributePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MetaAttributeEdgeSubscription
  extends Promise<AsyncIterator<MetaAttributeEdge>>,
    Fragmentable {
  node: <T = MetaAttributeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BizAttributeConnection {
  pageInfo: PageInfo;
  edges: BizAttributeEdge[];
}

export interface BizAttributeConnectionPromise
  extends Promise<BizAttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BizAttributeEdge>>() => T;
  aggregate: <T = AggregateBizAttributePromise>() => T;
}

export interface BizAttributeConnectionSubscription
  extends Promise<AsyncIterator<BizAttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BizAttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBizAttributeSubscription>() => T;
}

export interface AggregateDiagram {
  count: Int;
}

export interface AggregateDiagramPromise
  extends Promise<AggregateDiagram>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiagramSubscription
  extends Promise<AsyncIterator<AggregateDiagram>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlanSubscriptionPayload {
  mutation: MutationType;
  node: Plan;
  updatedFields: String[];
  previousValues: PlanPreviousValues;
}

export interface PlanSubscriptionPayloadPromise
  extends Promise<PlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlanPreviousValuesPromise>() => T;
}

export interface PlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlanPreviousValuesSubscription>() => T;
}

export interface WidgetEdge {
  node: Widget;
  cursor: String;
}

export interface WidgetEdgePromise extends Promise<WidgetEdge>, Fragmentable {
  node: <T = WidgetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WidgetEdgeSubscription
  extends Promise<AsyncIterator<WidgetEdge>>,
    Fragmentable {
  node: <T = WidgetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PlanPreviousValues {
  id: ID_Output;
  planData?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanPreviousValuesPromise
  extends Promise<PlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  planData: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanPreviousValuesSubscription
  extends Promise<AsyncIterator<PlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  planData: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Diagram {
  id: ID_Output;
  diagramData?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DiagramPromise extends Promise<Diagram>, Fragmentable {
  id: () => Promise<ID_Output>;
  diagramData: () => Promise<Json>;
  ownerBO: <T = BusinessObjectPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  participatingBOs: <T = FragmentableArray<BusinessObject>>(args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DiagramSubscription
  extends Promise<AsyncIterator<Diagram>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  diagramData: () => Promise<AsyncIterator<Json>>;
  ownerBO: <T = BusinessObjectSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  participatingBOs: <
    T = Promise<AsyncIterator<BusinessObjectSubscription>>
  >(args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TemplateMappingEdge {
  node: TemplateMapping;
  cursor: String;
}

export interface TemplateMappingEdgePromise
  extends Promise<TemplateMappingEdge>,
    Fragmentable {
  node: <T = TemplateMappingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TemplateMappingEdgeSubscription
  extends Promise<AsyncIterator<TemplateMappingEdge>>,
    Fragmentable {
  node: <T = TemplateMappingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PlanConfigSubscriptionPayload {
  mutation: MutationType;
  node: PlanConfig;
  updatedFields: String[];
  previousValues: PlanConfigPreviousValues;
}

export interface PlanConfigSubscriptionPayloadPromise
  extends Promise<PlanConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlanConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlanConfigPreviousValuesPromise>() => T;
}

export interface PlanConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlanConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlanConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlanConfigPreviousValuesSubscription>() => T;
}

export interface TemplateConfigEdge {
  node: TemplateConfig;
  cursor: String;
}

export interface TemplateConfigEdgePromise
  extends Promise<TemplateConfigEdge>,
    Fragmentable {
  node: <T = TemplateConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TemplateConfigEdgeSubscription
  extends Promise<AsyncIterator<TemplateConfigEdge>>,
    Fragmentable {
  node: <T = TemplateConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PlanConfigPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanConfigPreviousValuesPromise
  extends Promise<PlanConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<PlanConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TemplateConnection {
  pageInfo: PageInfo;
  edges: TemplateEdge[];
}

export interface TemplateConnectionPromise
  extends Promise<TemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TemplateEdge>>() => T;
  aggregate: <T = AggregateTemplatePromise>() => T;
}

export interface TemplateConnectionSubscription
  extends Promise<AsyncIterator<TemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTemplateSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface SystemSetupConnection {
  pageInfo: PageInfo;
  edges: SystemSetupEdge[];
}

export interface SystemSetupConnectionPromise
  extends Promise<SystemSetupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SystemSetupEdge>>() => T;
  aggregate: <T = AggregateSystemSetupPromise>() => T;
}

export interface SystemSetupConnectionSubscription
  extends Promise<AsyncIterator<SystemSetupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SystemSetupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSystemSetupSubscription>() => T;
}

export interface RenderColumnSubscriptionPayload {
  mutation: MutationType;
  node: RenderColumn;
  updatedFields: String[];
  previousValues: RenderColumnPreviousValues;
}

export interface RenderColumnSubscriptionPayloadPromise
  extends Promise<RenderColumnSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RenderColumnPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RenderColumnPreviousValuesPromise>() => T;
}

export interface RenderColumnSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RenderColumnSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RenderColumnSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RenderColumnPreviousValuesSubscription>() => T;
}

export interface StateMachineSchemaConnection {
  pageInfo: PageInfo;
  edges: StateMachineSchemaEdge[];
}

export interface StateMachineSchemaConnectionPromise
  extends Promise<StateMachineSchemaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StateMachineSchemaEdge>>() => T;
  aggregate: <T = AggregateStateMachineSchemaPromise>() => T;
}

export interface StateMachineSchemaConnectionSubscription
  extends Promise<AsyncIterator<StateMachineSchemaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<StateMachineSchemaEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateStateMachineSchemaSubscription>() => T;
}

export interface RenderColumnPreviousValues {
  id: ID_Output;
  width?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RenderColumnPreviousValuesPromise
  extends Promise<RenderColumnPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  width: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RenderColumnPreviousValuesSubscription
  extends Promise<AsyncIterator<RenderColumnPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  width: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StateMachineSchema {
  createdAt: DateTimeOutput;
  finalState: String;
  id: ID_Output;
  initialState: String;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface StateMachineSchemaPromise
  extends Promise<StateMachineSchema>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  finalState: () => Promise<String>;
  id: () => Promise<ID_Output>;
  initialState: () => Promise<String>;
  name: () => Promise<String>;
  sMTransitions: <T = FragmentableArray<SMTransition>>(args?: {
    where?: SMTransitionWhereInput;
    orderBy?: SMTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StateMachineSchemaSubscription
  extends Promise<AsyncIterator<StateMachineSchema>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  finalState: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  initialState: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  sMTransitions: <T = Promise<AsyncIterator<SMTransitionSubscription>>>(args?: {
    where?: SMTransitionWhereInput;
    orderBy?: SMTransitionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Plan {
  id: ID_Output;
  planData?: Json;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanPromise extends Promise<Plan>, Fragmentable {
  id: () => Promise<ID_Output>;
  planData: () => Promise<Json>;
  planBO: <T = BusinessObjectPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  itemBOs: <T = FragmentableArray<BusinessObject>>(args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PlanSubscription
  extends Promise<AsyncIterator<Plan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  planData: () => Promise<AsyncIterator<Json>>;
  planBO: <T = BusinessObjectSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  itemBOs: <T = Promise<AsyncIterator<BusinessObjectSubscription>>>(args?: {
    where?: BusinessObjectWhereInput;
    orderBy?: BusinessObjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RenderColumnConnection {
  pageInfo: PageInfo;
  edges: RenderColumnEdge[];
}

export interface RenderColumnConnectionPromise
  extends Promise<RenderColumnConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RenderColumnEdge>>() => T;
  aggregate: <T = AggregateRenderColumnPromise>() => T;
}

export interface RenderColumnConnectionSubscription
  extends Promise<AsyncIterator<RenderColumnConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RenderColumnEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRenderColumnSubscription>() => T;
}

export interface SMTransitionSubscriptionPayload {
  mutation: MutationType;
  node: SMTransition;
  updatedFields: String[];
  previousValues: SMTransitionPreviousValues;
}

export interface SMTransitionSubscriptionPayloadPromise
  extends Promise<SMTransitionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SMTransitionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SMTransitionPreviousValuesPromise>() => T;
}

export interface SMTransitionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SMTransitionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SMTransitionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SMTransitionPreviousValuesSubscription>() => T;
}

export interface AggregatePlan {
  count: Int;
}

export interface AggregatePlanPromise
  extends Promise<AggregatePlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlanSubscription
  extends Promise<AsyncIterator<AggregatePlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SMTransitionPreviousValues {
  createdAt: DateTimeOutput;
  event: String;
  from: String;
  id: ID_Output;
  to: String;
  updatedAt: DateTimeOutput;
}

export interface SMTransitionPreviousValuesPromise
  extends Promise<SMTransitionPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  event: () => Promise<String>;
  from: () => Promise<String>;
  id: () => Promise<ID_Output>;
  to: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SMTransitionPreviousValuesSubscription
  extends Promise<AsyncIterator<SMTransitionPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: () => Promise<AsyncIterator<String>>;
  from: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  to: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateMetaRelation {
  count: Int;
}

export interface AggregateMetaRelationPromise
  extends Promise<AggregateMetaRelation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMetaRelationSubscription
  extends Promise<AsyncIterator<AggregateMetaRelation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Widget {
  id: ID_Output;
  name?: String;
  type: WidgetType;
  width?: Int;
  boid?: String;
  text?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface WidgetPromise extends Promise<Widget>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<WidgetType>;
  width: () => Promise<Int>;
  boid: () => Promise<String>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface WidgetSubscription
  extends Promise<AsyncIterator<Widget>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<WidgetType>>;
  width: () => Promise<AsyncIterator<Int>>;
  boid: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MetaObjectEdge {
  node: MetaObject;
  cursor: String;
}

export interface MetaObjectEdgePromise
  extends Promise<MetaObjectEdge>,
    Fragmentable {
  node: <T = MetaObjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MetaObjectEdgeSubscription
  extends Promise<AsyncIterator<MetaObjectEdge>>,
    Fragmentable {
  node: <T = MetaObjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StateMachineSchemaSubscriptionPayload {
  mutation: MutationType;
  node: StateMachineSchema;
  updatedFields: String[];
  previousValues: StateMachineSchemaPreviousValues;
}

export interface StateMachineSchemaSubscriptionPayloadPromise
  extends Promise<StateMachineSchemaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StateMachineSchemaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StateMachineSchemaPreviousValuesPromise>() => T;
}

export interface StateMachineSchemaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StateMachineSchemaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StateMachineSchemaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StateMachineSchemaPreviousValuesSubscription>() => T;
}

export interface MetaAttributeConnection {
  pageInfo: PageInfo;
  edges: MetaAttributeEdge[];
}

export interface MetaAttributeConnectionPromise
  extends Promise<MetaAttributeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MetaAttributeEdge>>() => T;
  aggregate: <T = AggregateMetaAttributePromise>() => T;
}

export interface MetaAttributeConnectionSubscription
  extends Promise<AsyncIterator<MetaAttributeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MetaAttributeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMetaAttributeSubscription>() => T;
}

export interface StateMachineSchemaPreviousValues {
  createdAt: DateTimeOutput;
  finalState: String;
  id: ID_Output;
  initialState: String;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface StateMachineSchemaPreviousValuesPromise
  extends Promise<StateMachineSchemaPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  finalState: () => Promise<String>;
  id: () => Promise<ID_Output>;
  initialState: () => Promise<String>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StateMachineSchemaPreviousValuesSubscription
  extends Promise<AsyncIterator<StateMachineSchemaPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  finalState: () => Promise<AsyncIterator<String>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  initialState: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RenderColumn {
  id: ID_Output;
  width?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface RenderColumnPromise
  extends Promise<RenderColumn>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  widgets: <T = FragmentableArray<Widget>>(args?: {
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  width: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface RenderColumnSubscription
  extends Promise<AsyncIterator<RenderColumn>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  widgets: <T = Promise<AsyncIterator<WidgetSubscription>>>(args?: {
    where?: WidgetWhereInput;
    orderBy?: WidgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  width: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TemplateMapping {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TemplateMappingPromise
  extends Promise<TemplateMapping>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  template: <T = TemplatePromise>() => T;
  businessObject: <T = BusinessObjectPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TemplateMappingSubscription
  extends Promise<AsyncIterator<TemplateMapping>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  template: <T = TemplateSubscription>() => T;
  businessObject: <T = BusinessObjectSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SystemSetupSubscriptionPayload {
  mutation: MutationType;
  node: SystemSetup;
  updatedFields: String[];
  previousValues: SystemSetupPreviousValues;
}

export interface SystemSetupSubscriptionPayloadPromise
  extends Promise<SystemSetupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SystemSetupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SystemSetupPreviousValuesPromise>() => T;
}

export interface SystemSetupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SystemSetupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SystemSetupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SystemSetupPreviousValuesSubscription>() => T;
}

export interface AggregateSystemSetup {
  count: Int;
}

export interface AggregateSystemSetupPromise
  extends Promise<AggregateSystemSetup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSystemSetupSubscription
  extends Promise<AsyncIterator<AggregateSystemSetup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SystemSetupPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SystemSetupPreviousValuesPromise
  extends Promise<SystemSetupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SystemSetupPreviousValuesSubscription
  extends Promise<AsyncIterator<SystemSetupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SMTransitionEdge {
  node: SMTransition;
  cursor: String;
}

export interface SMTransitionEdgePromise
  extends Promise<SMTransitionEdge>,
    Fragmentable {
  node: <T = SMTransitionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SMTransitionEdgeSubscription
  extends Promise<AsyncIterator<SMTransitionEdge>>,
    Fragmentable {
  node: <T = SMTransitionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Template {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TemplatePromise extends Promise<Template>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  renderColumns: <T = FragmentableArray<RenderColumn>>(args?: {
    where?: RenderColumnWhereInput;
    orderBy?: RenderColumnOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TemplateSubscription
  extends Promise<AsyncIterator<Template>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  renderColumns: <T = Promise<AsyncIterator<RenderColumnSubscription>>>(args?: {
    where?: RenderColumnWhereInput;
    orderBy?: RenderColumnOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlanConfigEdge {
  node: PlanConfig;
  cursor: String;
}

export interface PlanConfigEdgePromise
  extends Promise<PlanConfigEdge>,
    Fragmentable {
  node: <T = PlanConfigPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlanConfigEdgeSubscription
  extends Promise<AsyncIterator<PlanConfigEdge>>,
    Fragmentable {
  node: <T = PlanConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TemplateSubscriptionPayload {
  mutation: MutationType;
  node: Template;
  updatedFields: String[];
  previousValues: TemplatePreviousValues;
}

export interface TemplateSubscriptionPayloadPromise
  extends Promise<TemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TemplatePreviousValuesPromise>() => T;
}

export interface TemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TemplatePreviousValuesSubscription>() => T;
}

export interface MetaRelationConnection {
  pageInfo: PageInfo;
  edges: MetaRelationEdge[];
}

export interface MetaRelationConnectionPromise
  extends Promise<MetaRelationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MetaRelationEdge>>() => T;
  aggregate: <T = AggregateMetaRelationPromise>() => T;
}

export interface MetaRelationConnectionSubscription
  extends Promise<AsyncIterator<MetaRelationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MetaRelationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMetaRelationSubscription>() => T;
}

export interface TemplatePreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TemplatePreviousValuesPromise
  extends Promise<TemplatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<TemplatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiagramEdge {
  node: Diagram;
  cursor: String;
}

export interface DiagramEdgePromise extends Promise<DiagramEdge>, Fragmentable {
  node: <T = DiagramPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiagramEdgeSubscription
  extends Promise<AsyncIterator<DiagramEdge>>,
    Fragmentable {
  node: <T = DiagramSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TemplateConfig {
  id: ID_Output;
  userRelatedMRId?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TemplateConfigPromise
  extends Promise<TemplateConfig>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  moObject: <T = MetaObjectPromise>() => T;
  moRelation: <T = MetaRelationPromise>() => T;
  userRelatedMRId: () => Promise<String>;
  defaultTemplate: <T = TemplatePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TemplateConfigSubscription
  extends Promise<AsyncIterator<TemplateConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  moObject: <T = MetaObjectSubscription>() => T;
  moRelation: <T = MetaRelationSubscription>() => T;
  userRelatedMRId: () => Promise<AsyncIterator<String>>;
  defaultTemplate: <T = TemplateSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTemplate {
  count: Int;
}

export interface AggregateTemplatePromise
  extends Promise<AggregateTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTemplateSubscription
  extends Promise<AsyncIterator<AggregateTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateRenderColumn {
  count: Int;
}

export interface AggregateRenderColumnPromise
  extends Promise<AggregateRenderColumn>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRenderColumnSubscription
  extends Promise<AsyncIterator<AggregateRenderColumn>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TemplateMappingSubscriptionPayload {
  mutation: MutationType;
  node: TemplateMapping;
  updatedFields: String[];
  previousValues: TemplateMappingPreviousValues;
}

export interface TemplateMappingSubscriptionPayloadPromise
  extends Promise<TemplateMappingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TemplateMappingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TemplateMappingPreviousValuesPromise>() => T;
}

export interface TemplateMappingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TemplateMappingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TemplateMappingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TemplateMappingPreviousValuesSubscription>() => T;
}

export interface PlanConfig {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlanConfigPromise extends Promise<PlanConfig>, Fragmentable {
  id: () => Promise<ID_Output>;
  uiMoPlan: <T = MetaObjectPromise>() => T;
  uiMoRelations: <T = FragmentableArray<MetaRelation>>(args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlanConfigSubscription
  extends Promise<AsyncIterator<PlanConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uiMoPlan: <T = MetaObjectSubscription>() => T;
  uiMoRelations: <T = Promise<AsyncIterator<MetaRelationSubscription>>>(args?: {
    where?: MetaRelationWhereInput;
    orderBy?: MetaRelationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TemplateConfigPreviousValues {
  id: ID_Output;
  userRelatedMRId?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TemplateConfigPreviousValuesPromise
  extends Promise<TemplateConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userRelatedMRId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TemplateConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<TemplateConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userRelatedMRId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TemplateConfigSubscriptionPayload {
  mutation: MutationType;
  node: TemplateConfig;
  updatedFields: String[];
  previousValues: TemplateConfigPreviousValues;
}

export interface TemplateConfigSubscriptionPayloadPromise
  extends Promise<TemplateConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TemplateConfigPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TemplateConfigPreviousValuesPromise>() => T;
}

export interface TemplateConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TemplateConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TemplateConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TemplateConfigPreviousValuesSubscription>() => T;
}

export interface PlanConnection {
  pageInfo: PageInfo;
  edges: PlanEdge[];
}

export interface PlanConnectionPromise
  extends Promise<PlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlanEdge>>() => T;
  aggregate: <T = AggregatePlanPromise>() => T;
}

export interface PlanConnectionSubscription
  extends Promise<AsyncIterator<PlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlanSubscription>() => T;
}

export interface AggregateStateMachineSchema {
  count: Int;
}

export interface AggregateStateMachineSchemaPromise
  extends Promise<AggregateStateMachineSchema>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStateMachineSchemaSubscription
  extends Promise<AsyncIterator<AggregateStateMachineSchema>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  userid?: String;
  password?: String;
  name?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  userid: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userid: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateMetaAttribute {
  count: Int;
}

export interface AggregateMetaAttributePromise
  extends Promise<AggregateMetaAttribute>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMetaAttributeSubscription
  extends Promise<AsyncIterator<AggregateMetaAttribute>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AttributeType",
    embedded: false
  },
  {
    name: "WidgetType",
    embedded: false
  },
  {
    name: "BizAttribute",
    embedded: false
  },
  {
    name: "BizRelation",
    embedded: false
  },
  {
    name: "BusinessObject",
    embedded: false
  },
  {
    name: "MetaAttribute",
    embedded: false
  },
  {
    name: "MetaObject",
    embedded: false
  },
  {
    name: "MetaRelation",
    embedded: false
  },
  {
    name: "MultiplicityType",
    embedded: false
  },
  {
    name: "SMTransition",
    embedded: false
  },
  {
    name: "StateMachineSchema",
    embedded: false
  },
  {
    name: "PlanConfig",
    embedded: false
  },
  {
    name: "Plan",
    embedded: false
  },
  {
    name: "TemplateConfig",
    embedded: false
  },
  {
    name: "TemplateMapping",
    embedded: false
  },
  {
    name: "Template",
    embedded: false
  },
  {
    name: "RenderColumn",
    embedded: false
  },
  {
    name: "Widget",
    embedded: false
  },
  {
    name: "SystemSetup",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Diagram",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/robohub-c21015/BEAM/dev`
});
export const prisma = new Prisma();
