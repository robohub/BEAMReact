// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBizAttribute {
  count: Int!
}

type AggregateBizRelation {
  count: Int!
}

type AggregateBusinessObject {
  count: Int!
}

type AggregateDiagram {
  count: Int!
}

type AggregateMetaAttribute {
  count: Int!
}

type AggregateMetaObject {
  count: Int!
}

type AggregateMetaRelation {
  count: Int!
}

type AggregatePlan {
  count: Int!
}

type AggregatePlanConfig {
  count: Int!
}

type AggregateRenderColumn {
  count: Int!
}

type AggregateSMTransition {
  count: Int!
}

type AggregateStateMachineSchema {
  count: Int!
}

type AggregateSystemSetup {
  count: Int!
}

type AggregateTemplate {
  count: Int!
}

type AggregateTemplateConfig {
  count: Int!
}

type AggregateTemplateMapping {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWidget {
  count: Int!
}

enum AttributeType {
  String
  Int
  Float
  DateTime
  Boolean
}

type BatchPayload {
  count: Long!
}

type BizAttribute {
  businessObject: BusinessObject
  createdAt: DateTime!
  id: ID!
  metaAttribute: MetaAttribute
  updatedAt: DateTime!
  value: String!
}

type BizAttributeConnection {
  pageInfo: PageInfo!
  edges: [BizAttributeEdge]!
  aggregate: AggregateBizAttribute!
}

input BizAttributeCreateInput {
  businessObject: BusinessObjectCreateOneWithoutBizAttributesInput
  id: ID
  metaAttribute: MetaAttributeCreateOneWithoutBizAttributesInput
  value: String!
}

input BizAttributeCreateManyWithoutBusinessObjectInput {
  create: [BizAttributeCreateWithoutBusinessObjectInput!]
  connect: [BizAttributeWhereUniqueInput!]
}

input BizAttributeCreateManyWithoutMetaAttributeInput {
  create: [BizAttributeCreateWithoutMetaAttributeInput!]
  connect: [BizAttributeWhereUniqueInput!]
}

input BizAttributeCreateWithoutBusinessObjectInput {
  id: ID
  metaAttribute: MetaAttributeCreateOneWithoutBizAttributesInput
  value: String!
}

input BizAttributeCreateWithoutMetaAttributeInput {
  businessObject: BusinessObjectCreateOneWithoutBizAttributesInput
  id: ID
  value: String!
}

type BizAttributeEdge {
  node: BizAttribute!
  cursor: String!
}

enum BizAttributeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  value_ASC
  value_DESC
}

type BizAttributePreviousValues {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  value: String!
}

input BizAttributeScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [BizAttributeScalarWhereInput!]
  OR: [BizAttributeScalarWhereInput!]
  NOT: [BizAttributeScalarWhereInput!]
}

type BizAttributeSubscriptionPayload {
  mutation: MutationType!
  node: BizAttribute
  updatedFields: [String!]
  previousValues: BizAttributePreviousValues
}

input BizAttributeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BizAttributeWhereInput
  AND: [BizAttributeSubscriptionWhereInput!]
  OR: [BizAttributeSubscriptionWhereInput!]
  NOT: [BizAttributeSubscriptionWhereInput!]
}

input BizAttributeUpdateInput {
  businessObject: BusinessObjectUpdateOneWithoutBizAttributesInput
  metaAttribute: MetaAttributeUpdateOneWithoutBizAttributesInput
  value: String
}

input BizAttributeUpdateManyDataInput {
  value: String
}

input BizAttributeUpdateManyMutationInput {
  value: String
}

input BizAttributeUpdateManyWithoutBusinessObjectInput {
  create: [BizAttributeCreateWithoutBusinessObjectInput!]
  delete: [BizAttributeWhereUniqueInput!]
  connect: [BizAttributeWhereUniqueInput!]
  set: [BizAttributeWhereUniqueInput!]
  disconnect: [BizAttributeWhereUniqueInput!]
  update: [BizAttributeUpdateWithWhereUniqueWithoutBusinessObjectInput!]
  upsert: [BizAttributeUpsertWithWhereUniqueWithoutBusinessObjectInput!]
  deleteMany: [BizAttributeScalarWhereInput!]
  updateMany: [BizAttributeUpdateManyWithWhereNestedInput!]
}

input BizAttributeUpdateManyWithoutMetaAttributeInput {
  create: [BizAttributeCreateWithoutMetaAttributeInput!]
  delete: [BizAttributeWhereUniqueInput!]
  connect: [BizAttributeWhereUniqueInput!]
  set: [BizAttributeWhereUniqueInput!]
  disconnect: [BizAttributeWhereUniqueInput!]
  update: [BizAttributeUpdateWithWhereUniqueWithoutMetaAttributeInput!]
  upsert: [BizAttributeUpsertWithWhereUniqueWithoutMetaAttributeInput!]
  deleteMany: [BizAttributeScalarWhereInput!]
  updateMany: [BizAttributeUpdateManyWithWhereNestedInput!]
}

input BizAttributeUpdateManyWithWhereNestedInput {
  where: BizAttributeScalarWhereInput!
  data: BizAttributeUpdateManyDataInput!
}

input BizAttributeUpdateWithoutBusinessObjectDataInput {
  metaAttribute: MetaAttributeUpdateOneWithoutBizAttributesInput
  value: String
}

input BizAttributeUpdateWithoutMetaAttributeDataInput {
  businessObject: BusinessObjectUpdateOneWithoutBizAttributesInput
  value: String
}

input BizAttributeUpdateWithWhereUniqueWithoutBusinessObjectInput {
  where: BizAttributeWhereUniqueInput!
  data: BizAttributeUpdateWithoutBusinessObjectDataInput!
}

input BizAttributeUpdateWithWhereUniqueWithoutMetaAttributeInput {
  where: BizAttributeWhereUniqueInput!
  data: BizAttributeUpdateWithoutMetaAttributeDataInput!
}

input BizAttributeUpsertWithWhereUniqueWithoutBusinessObjectInput {
  where: BizAttributeWhereUniqueInput!
  update: BizAttributeUpdateWithoutBusinessObjectDataInput!
  create: BizAttributeCreateWithoutBusinessObjectInput!
}

input BizAttributeUpsertWithWhereUniqueWithoutMetaAttributeInput {
  where: BizAttributeWhereUniqueInput!
  update: BizAttributeUpdateWithoutMetaAttributeDataInput!
  create: BizAttributeCreateWithoutMetaAttributeInput!
}

input BizAttributeWhereInput {
  businessObject: BusinessObjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  metaAttribute: MetaAttributeWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [BizAttributeWhereInput!]
  OR: [BizAttributeWhereInput!]
  NOT: [BizAttributeWhereInput!]
}

input BizAttributeWhereUniqueInput {
  id: ID
}

type BizRelation {
  createdAt: DateTime!
  id: ID!
  incomingObject: BusinessObject
  metaRelation: MetaRelation
  oppositeObject: BusinessObject
  oppositeRelation: BizRelation
  updatedAt: DateTime!
}

type BizRelationConnection {
  pageInfo: PageInfo!
  edges: [BizRelationEdge]!
  aggregate: AggregateBizRelation!
}

input BizRelationCreateInput {
  id: ID
  incomingObject: BusinessObjectCreateOneWithoutOutgoingRelationsInput
  metaRelation: MetaRelationCreateOneWithoutBizRelationsInput
  oppositeObject: BusinessObjectCreateOneWithoutIncomingRelationsInput
  oppositeRelation: BizRelationCreateOneWithoutOppositeRelationInput
}

input BizRelationCreateManyWithoutIncomingObjectInput {
  create: [BizRelationCreateWithoutIncomingObjectInput!]
  connect: [BizRelationWhereUniqueInput!]
}

input BizRelationCreateManyWithoutMetaRelationInput {
  create: [BizRelationCreateWithoutMetaRelationInput!]
  connect: [BizRelationWhereUniqueInput!]
}

input BizRelationCreateManyWithoutOppositeObjectInput {
  create: [BizRelationCreateWithoutOppositeObjectInput!]
  connect: [BizRelationWhereUniqueInput!]
}

input BizRelationCreateOneWithoutOppositeRelationInput {
  create: BizRelationCreateWithoutOppositeRelationInput
  connect: BizRelationWhereUniqueInput
}

input BizRelationCreateWithoutIncomingObjectInput {
  id: ID
  metaRelation: MetaRelationCreateOneWithoutBizRelationsInput
  oppositeObject: BusinessObjectCreateOneWithoutIncomingRelationsInput
  oppositeRelation: BizRelationCreateOneWithoutOppositeRelationInput
}

input BizRelationCreateWithoutMetaRelationInput {
  id: ID
  incomingObject: BusinessObjectCreateOneWithoutOutgoingRelationsInput
  oppositeObject: BusinessObjectCreateOneWithoutIncomingRelationsInput
  oppositeRelation: BizRelationCreateOneWithoutOppositeRelationInput
}

input BizRelationCreateWithoutOppositeObjectInput {
  id: ID
  incomingObject: BusinessObjectCreateOneWithoutOutgoingRelationsInput
  metaRelation: MetaRelationCreateOneWithoutBizRelationsInput
  oppositeRelation: BizRelationCreateOneWithoutOppositeRelationInput
}

input BizRelationCreateWithoutOppositeRelationInput {
  id: ID
  incomingObject: BusinessObjectCreateOneWithoutOutgoingRelationsInput
  metaRelation: MetaRelationCreateOneWithoutBizRelationsInput
  oppositeObject: BusinessObjectCreateOneWithoutIncomingRelationsInput
}

type BizRelationEdge {
  node: BizRelation!
  cursor: String!
}

enum BizRelationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BizRelationPreviousValues {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

input BizRelationScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BizRelationScalarWhereInput!]
  OR: [BizRelationScalarWhereInput!]
  NOT: [BizRelationScalarWhereInput!]
}

type BizRelationSubscriptionPayload {
  mutation: MutationType!
  node: BizRelation
  updatedFields: [String!]
  previousValues: BizRelationPreviousValues
}

input BizRelationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BizRelationWhereInput
  AND: [BizRelationSubscriptionWhereInput!]
  OR: [BizRelationSubscriptionWhereInput!]
  NOT: [BizRelationSubscriptionWhereInput!]
}

input BizRelationUpdateInput {
  incomingObject: BusinessObjectUpdateOneWithoutOutgoingRelationsInput
  metaRelation: MetaRelationUpdateOneWithoutBizRelationsInput
  oppositeObject: BusinessObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: BizRelationUpdateOneWithoutOppositeRelationInput
}

input BizRelationUpdateManyWithoutIncomingObjectInput {
  create: [BizRelationCreateWithoutIncomingObjectInput!]
  delete: [BizRelationWhereUniqueInput!]
  connect: [BizRelationWhereUniqueInput!]
  set: [BizRelationWhereUniqueInput!]
  disconnect: [BizRelationWhereUniqueInput!]
  update: [BizRelationUpdateWithWhereUniqueWithoutIncomingObjectInput!]
  upsert: [BizRelationUpsertWithWhereUniqueWithoutIncomingObjectInput!]
  deleteMany: [BizRelationScalarWhereInput!]
}

input BizRelationUpdateManyWithoutMetaRelationInput {
  create: [BizRelationCreateWithoutMetaRelationInput!]
  delete: [BizRelationWhereUniqueInput!]
  connect: [BizRelationWhereUniqueInput!]
  set: [BizRelationWhereUniqueInput!]
  disconnect: [BizRelationWhereUniqueInput!]
  update: [BizRelationUpdateWithWhereUniqueWithoutMetaRelationInput!]
  upsert: [BizRelationUpsertWithWhereUniqueWithoutMetaRelationInput!]
  deleteMany: [BizRelationScalarWhereInput!]
}

input BizRelationUpdateManyWithoutOppositeObjectInput {
  create: [BizRelationCreateWithoutOppositeObjectInput!]
  delete: [BizRelationWhereUniqueInput!]
  connect: [BizRelationWhereUniqueInput!]
  set: [BizRelationWhereUniqueInput!]
  disconnect: [BizRelationWhereUniqueInput!]
  update: [BizRelationUpdateWithWhereUniqueWithoutOppositeObjectInput!]
  upsert: [BizRelationUpsertWithWhereUniqueWithoutOppositeObjectInput!]
  deleteMany: [BizRelationScalarWhereInput!]
}

input BizRelationUpdateOneWithoutOppositeRelationInput {
  create: BizRelationCreateWithoutOppositeRelationInput
  update: BizRelationUpdateWithoutOppositeRelationDataInput
  upsert: BizRelationUpsertWithoutOppositeRelationInput
  delete: Boolean
  disconnect: Boolean
  connect: BizRelationWhereUniqueInput
}

input BizRelationUpdateWithoutIncomingObjectDataInput {
  metaRelation: MetaRelationUpdateOneWithoutBizRelationsInput
  oppositeObject: BusinessObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: BizRelationUpdateOneWithoutOppositeRelationInput
}

input BizRelationUpdateWithoutMetaRelationDataInput {
  incomingObject: BusinessObjectUpdateOneWithoutOutgoingRelationsInput
  oppositeObject: BusinessObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: BizRelationUpdateOneWithoutOppositeRelationInput
}

input BizRelationUpdateWithoutOppositeObjectDataInput {
  incomingObject: BusinessObjectUpdateOneWithoutOutgoingRelationsInput
  metaRelation: MetaRelationUpdateOneWithoutBizRelationsInput
  oppositeRelation: BizRelationUpdateOneWithoutOppositeRelationInput
}

input BizRelationUpdateWithoutOppositeRelationDataInput {
  incomingObject: BusinessObjectUpdateOneWithoutOutgoingRelationsInput
  metaRelation: MetaRelationUpdateOneWithoutBizRelationsInput
  oppositeObject: BusinessObjectUpdateOneWithoutIncomingRelationsInput
}

input BizRelationUpdateWithWhereUniqueWithoutIncomingObjectInput {
  where: BizRelationWhereUniqueInput!
  data: BizRelationUpdateWithoutIncomingObjectDataInput!
}

input BizRelationUpdateWithWhereUniqueWithoutMetaRelationInput {
  where: BizRelationWhereUniqueInput!
  data: BizRelationUpdateWithoutMetaRelationDataInput!
}

input BizRelationUpdateWithWhereUniqueWithoutOppositeObjectInput {
  where: BizRelationWhereUniqueInput!
  data: BizRelationUpdateWithoutOppositeObjectDataInput!
}

input BizRelationUpsertWithoutOppositeRelationInput {
  update: BizRelationUpdateWithoutOppositeRelationDataInput!
  create: BizRelationCreateWithoutOppositeRelationInput!
}

input BizRelationUpsertWithWhereUniqueWithoutIncomingObjectInput {
  where: BizRelationWhereUniqueInput!
  update: BizRelationUpdateWithoutIncomingObjectDataInput!
  create: BizRelationCreateWithoutIncomingObjectInput!
}

input BizRelationUpsertWithWhereUniqueWithoutMetaRelationInput {
  where: BizRelationWhereUniqueInput!
  update: BizRelationUpdateWithoutMetaRelationDataInput!
  create: BizRelationCreateWithoutMetaRelationInput!
}

input BizRelationUpsertWithWhereUniqueWithoutOppositeObjectInput {
  where: BizRelationWhereUniqueInput!
  update: BizRelationUpdateWithoutOppositeObjectDataInput!
  create: BizRelationCreateWithoutOppositeObjectInput!
}

input BizRelationWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  incomingObject: BusinessObjectWhereInput
  metaRelation: MetaRelationWhereInput
  oppositeObject: BusinessObjectWhereInput
  oppositeRelation: BizRelationWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BizRelationWhereInput!]
  OR: [BizRelationWhereInput!]
  NOT: [BizRelationWhereInput!]
}

input BizRelationWhereUniqueInput {
  id: ID
}

type BusinessObject {
  bizAttributes(where: BizAttributeWhereInput, orderBy: BizAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizAttribute!]
  createdAt: DateTime!
  id: ID!
  incomingRelations(where: BizRelationWhereInput, orderBy: BizRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizRelation!]
  metaObject: MetaObject
  name: String
  outgoingRelations(where: BizRelationWhereInput, orderBy: BizRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizRelation!]
  state: String
  tags: [String!]!
  updatedAt: DateTime!
  plan: Plan
  plannedIn: Plan
  ownsDiagrams(where: DiagramWhereInput, orderBy: DiagramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagram!]
  participatesInDiagrams(where: DiagramWhereInput, orderBy: DiagramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagram!]
}

type BusinessObjectConnection {
  pageInfo: PageInfo!
  edges: [BusinessObjectEdge]!
  aggregate: AggregateBusinessObject!
}

input BusinessObjectCreateInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateManyWithoutMetaObjectInput {
  create: [BusinessObjectCreateWithoutMetaObjectInput!]
  connect: [BusinessObjectWhereUniqueInput!]
}

input BusinessObjectCreateManyWithoutParticipatesInDiagramsInput {
  create: [BusinessObjectCreateWithoutParticipatesInDiagramsInput!]
  connect: [BusinessObjectWhereUniqueInput!]
}

input BusinessObjectCreateManyWithoutPlannedInInput {
  create: [BusinessObjectCreateWithoutPlannedInInput!]
  connect: [BusinessObjectWhereUniqueInput!]
}

input BusinessObjectCreateOneInput {
  create: BusinessObjectCreateInput
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectCreateOneWithoutBizAttributesInput {
  create: BusinessObjectCreateWithoutBizAttributesInput
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectCreateOneWithoutIncomingRelationsInput {
  create: BusinessObjectCreateWithoutIncomingRelationsInput
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectCreateOneWithoutOutgoingRelationsInput {
  create: BusinessObjectCreateWithoutOutgoingRelationsInput
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectCreateOneWithoutOwnsDiagramsInput {
  create: BusinessObjectCreateWithoutOwnsDiagramsInput
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectCreateOneWithoutPlanInput {
  create: BusinessObjectCreateWithoutPlanInput
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectCreatetagsInput {
  set: [String!]
}

input BusinessObjectCreateWithoutBizAttributesInput {
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateWithoutIncomingRelationsInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateWithoutMetaObjectInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateWithoutOutgoingRelationsInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateWithoutOwnsDiagramsInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateWithoutParticipatesInDiagramsInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
}

input BusinessObjectCreateWithoutPlanInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plannedIn: PlanCreateOneWithoutItemBOsInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

input BusinessObjectCreateWithoutPlannedInInput {
  bizAttributes: BizAttributeCreateManyWithoutBusinessObjectInput
  id: ID
  incomingRelations: BizRelationCreateManyWithoutOppositeObjectInput
  metaObject: MetaObjectCreateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationCreateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectCreatetagsInput
  plan: PlanCreateOneWithoutPlanBOInput
  ownsDiagrams: DiagramCreateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramCreateManyWithoutParticipatingBOsInput
}

type BusinessObjectEdge {
  node: BusinessObject!
  cursor: String!
}

enum BusinessObjectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  state_ASC
  state_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BusinessObjectPreviousValues {
  createdAt: DateTime!
  id: ID!
  name: String
  state: String
  tags: [String!]!
  updatedAt: DateTime!
}

input BusinessObjectScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BusinessObjectScalarWhereInput!]
  OR: [BusinessObjectScalarWhereInput!]
  NOT: [BusinessObjectScalarWhereInput!]
}

type BusinessObjectSubscriptionPayload {
  mutation: MutationType!
  node: BusinessObject
  updatedFields: [String!]
  previousValues: BusinessObjectPreviousValues
}

input BusinessObjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BusinessObjectWhereInput
  AND: [BusinessObjectSubscriptionWhereInput!]
  OR: [BusinessObjectSubscriptionWhereInput!]
  NOT: [BusinessObjectSubscriptionWhereInput!]
}

input BusinessObjectUpdateDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateManyDataInput {
  name: String
  state: String
  tags: BusinessObjectUpdatetagsInput
}

input BusinessObjectUpdateManyMutationInput {
  name: String
  state: String
  tags: BusinessObjectUpdatetagsInput
}

input BusinessObjectUpdateManyWithoutMetaObjectInput {
  create: [BusinessObjectCreateWithoutMetaObjectInput!]
  delete: [BusinessObjectWhereUniqueInput!]
  connect: [BusinessObjectWhereUniqueInput!]
  set: [BusinessObjectWhereUniqueInput!]
  disconnect: [BusinessObjectWhereUniqueInput!]
  update: [BusinessObjectUpdateWithWhereUniqueWithoutMetaObjectInput!]
  upsert: [BusinessObjectUpsertWithWhereUniqueWithoutMetaObjectInput!]
  deleteMany: [BusinessObjectScalarWhereInput!]
  updateMany: [BusinessObjectUpdateManyWithWhereNestedInput!]
}

input BusinessObjectUpdateManyWithoutParticipatesInDiagramsInput {
  create: [BusinessObjectCreateWithoutParticipatesInDiagramsInput!]
  delete: [BusinessObjectWhereUniqueInput!]
  connect: [BusinessObjectWhereUniqueInput!]
  set: [BusinessObjectWhereUniqueInput!]
  disconnect: [BusinessObjectWhereUniqueInput!]
  update: [BusinessObjectUpdateWithWhereUniqueWithoutParticipatesInDiagramsInput!]
  upsert: [BusinessObjectUpsertWithWhereUniqueWithoutParticipatesInDiagramsInput!]
  deleteMany: [BusinessObjectScalarWhereInput!]
  updateMany: [BusinessObjectUpdateManyWithWhereNestedInput!]
}

input BusinessObjectUpdateManyWithoutPlannedInInput {
  create: [BusinessObjectCreateWithoutPlannedInInput!]
  delete: [BusinessObjectWhereUniqueInput!]
  connect: [BusinessObjectWhereUniqueInput!]
  set: [BusinessObjectWhereUniqueInput!]
  disconnect: [BusinessObjectWhereUniqueInput!]
  update: [BusinessObjectUpdateWithWhereUniqueWithoutPlannedInInput!]
  upsert: [BusinessObjectUpsertWithWhereUniqueWithoutPlannedInInput!]
  deleteMany: [BusinessObjectScalarWhereInput!]
  updateMany: [BusinessObjectUpdateManyWithWhereNestedInput!]
}

input BusinessObjectUpdateManyWithWhereNestedInput {
  where: BusinessObjectScalarWhereInput!
  data: BusinessObjectUpdateManyDataInput!
}

input BusinessObjectUpdateOneInput {
  create: BusinessObjectCreateInput
  update: BusinessObjectUpdateDataInput
  upsert: BusinessObjectUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectUpdateOneWithoutBizAttributesInput {
  create: BusinessObjectCreateWithoutBizAttributesInput
  update: BusinessObjectUpdateWithoutBizAttributesDataInput
  upsert: BusinessObjectUpsertWithoutBizAttributesInput
  delete: Boolean
  disconnect: Boolean
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectUpdateOneWithoutIncomingRelationsInput {
  create: BusinessObjectCreateWithoutIncomingRelationsInput
  update: BusinessObjectUpdateWithoutIncomingRelationsDataInput
  upsert: BusinessObjectUpsertWithoutIncomingRelationsInput
  delete: Boolean
  disconnect: Boolean
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectUpdateOneWithoutOutgoingRelationsInput {
  create: BusinessObjectCreateWithoutOutgoingRelationsInput
  update: BusinessObjectUpdateWithoutOutgoingRelationsDataInput
  upsert: BusinessObjectUpsertWithoutOutgoingRelationsInput
  delete: Boolean
  disconnect: Boolean
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectUpdateOneWithoutOwnsDiagramsInput {
  create: BusinessObjectCreateWithoutOwnsDiagramsInput
  update: BusinessObjectUpdateWithoutOwnsDiagramsDataInput
  upsert: BusinessObjectUpsertWithoutOwnsDiagramsInput
  delete: Boolean
  disconnect: Boolean
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectUpdateOneWithoutPlanInput {
  create: BusinessObjectCreateWithoutPlanInput
  update: BusinessObjectUpdateWithoutPlanDataInput
  upsert: BusinessObjectUpsertWithoutPlanInput
  delete: Boolean
  disconnect: Boolean
  connect: BusinessObjectWhereUniqueInput
}

input BusinessObjectUpdatetagsInput {
  set: [String!]
}

input BusinessObjectUpdateWithoutBizAttributesDataInput {
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithoutIncomingRelationsDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithoutMetaObjectDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithoutOutgoingRelationsDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithoutOwnsDiagramsDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithoutParticipatesInDiagramsDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
}

input BusinessObjectUpdateWithoutPlanDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plannedIn: PlanUpdateOneWithoutItemBOsInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithoutPlannedInDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutBusinessObjectInput
  incomingRelations: BizRelationUpdateManyWithoutOppositeObjectInput
  metaObject: MetaObjectUpdateOneWithoutBusinessObjectsInput
  name: String
  outgoingRelations: BizRelationUpdateManyWithoutIncomingObjectInput
  state: String
  tags: BusinessObjectUpdatetagsInput
  plan: PlanUpdateOneWithoutPlanBOInput
  ownsDiagrams: DiagramUpdateManyWithoutOwnerBOInput
  participatesInDiagrams: DiagramUpdateManyWithoutParticipatingBOsInput
}

input BusinessObjectUpdateWithWhereUniqueWithoutMetaObjectInput {
  where: BusinessObjectWhereUniqueInput!
  data: BusinessObjectUpdateWithoutMetaObjectDataInput!
}

input BusinessObjectUpdateWithWhereUniqueWithoutParticipatesInDiagramsInput {
  where: BusinessObjectWhereUniqueInput!
  data: BusinessObjectUpdateWithoutParticipatesInDiagramsDataInput!
}

input BusinessObjectUpdateWithWhereUniqueWithoutPlannedInInput {
  where: BusinessObjectWhereUniqueInput!
  data: BusinessObjectUpdateWithoutPlannedInDataInput!
}

input BusinessObjectUpsertNestedInput {
  update: BusinessObjectUpdateDataInput!
  create: BusinessObjectCreateInput!
}

input BusinessObjectUpsertWithoutBizAttributesInput {
  update: BusinessObjectUpdateWithoutBizAttributesDataInput!
  create: BusinessObjectCreateWithoutBizAttributesInput!
}

input BusinessObjectUpsertWithoutIncomingRelationsInput {
  update: BusinessObjectUpdateWithoutIncomingRelationsDataInput!
  create: BusinessObjectCreateWithoutIncomingRelationsInput!
}

input BusinessObjectUpsertWithoutOutgoingRelationsInput {
  update: BusinessObjectUpdateWithoutOutgoingRelationsDataInput!
  create: BusinessObjectCreateWithoutOutgoingRelationsInput!
}

input BusinessObjectUpsertWithoutOwnsDiagramsInput {
  update: BusinessObjectUpdateWithoutOwnsDiagramsDataInput!
  create: BusinessObjectCreateWithoutOwnsDiagramsInput!
}

input BusinessObjectUpsertWithoutPlanInput {
  update: BusinessObjectUpdateWithoutPlanDataInput!
  create: BusinessObjectCreateWithoutPlanInput!
}

input BusinessObjectUpsertWithWhereUniqueWithoutMetaObjectInput {
  where: BusinessObjectWhereUniqueInput!
  update: BusinessObjectUpdateWithoutMetaObjectDataInput!
  create: BusinessObjectCreateWithoutMetaObjectInput!
}

input BusinessObjectUpsertWithWhereUniqueWithoutParticipatesInDiagramsInput {
  where: BusinessObjectWhereUniqueInput!
  update: BusinessObjectUpdateWithoutParticipatesInDiagramsDataInput!
  create: BusinessObjectCreateWithoutParticipatesInDiagramsInput!
}

input BusinessObjectUpsertWithWhereUniqueWithoutPlannedInInput {
  where: BusinessObjectWhereUniqueInput!
  update: BusinessObjectUpdateWithoutPlannedInDataInput!
  create: BusinessObjectCreateWithoutPlannedInInput!
}

input BusinessObjectWhereInput {
  bizAttributes_every: BizAttributeWhereInput
  bizAttributes_some: BizAttributeWhereInput
  bizAttributes_none: BizAttributeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  incomingRelations_every: BizRelationWhereInput
  incomingRelations_some: BizRelationWhereInput
  incomingRelations_none: BizRelationWhereInput
  metaObject: MetaObjectWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  outgoingRelations_every: BizRelationWhereInput
  outgoingRelations_some: BizRelationWhereInput
  outgoingRelations_none: BizRelationWhereInput
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  plan: PlanWhereInput
  plannedIn: PlanWhereInput
  ownsDiagrams_every: DiagramWhereInput
  ownsDiagrams_some: DiagramWhereInput
  ownsDiagrams_none: DiagramWhereInput
  participatesInDiagrams_every: DiagramWhereInput
  participatesInDiagrams_some: DiagramWhereInput
  participatesInDiagrams_none: DiagramWhereInput
  AND: [BusinessObjectWhereInput!]
  OR: [BusinessObjectWhereInput!]
  NOT: [BusinessObjectWhereInput!]
}

input BusinessObjectWhereUniqueInput {
  id: ID
}

scalar DateTime

type Diagram {
  id: ID!
  diagramData: Json
  ownerBO: BusinessObject
  createdAt: DateTime!
  updatedAt: DateTime!
  participatingBOs(where: BusinessObjectWhereInput, orderBy: BusinessObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BusinessObject!]
}

type DiagramConnection {
  pageInfo: PageInfo!
  edges: [DiagramEdge]!
  aggregate: AggregateDiagram!
}

input DiagramCreateInput {
  id: ID
  diagramData: Json
  ownerBO: BusinessObjectCreateOneWithoutOwnsDiagramsInput
  participatingBOs: BusinessObjectCreateManyWithoutParticipatesInDiagramsInput
}

input DiagramCreateManyWithoutOwnerBOInput {
  create: [DiagramCreateWithoutOwnerBOInput!]
  connect: [DiagramWhereUniqueInput!]
}

input DiagramCreateManyWithoutParticipatingBOsInput {
  create: [DiagramCreateWithoutParticipatingBOsInput!]
  connect: [DiagramWhereUniqueInput!]
}

input DiagramCreateWithoutOwnerBOInput {
  id: ID
  diagramData: Json
  participatingBOs: BusinessObjectCreateManyWithoutParticipatesInDiagramsInput
}

input DiagramCreateWithoutParticipatingBOsInput {
  id: ID
  diagramData: Json
  ownerBO: BusinessObjectCreateOneWithoutOwnsDiagramsInput
}

type DiagramEdge {
  node: Diagram!
  cursor: String!
}

enum DiagramOrderByInput {
  id_ASC
  id_DESC
  diagramData_ASC
  diagramData_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DiagramPreviousValues {
  id: ID!
  diagramData: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

input DiagramScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DiagramScalarWhereInput!]
  OR: [DiagramScalarWhereInput!]
  NOT: [DiagramScalarWhereInput!]
}

type DiagramSubscriptionPayload {
  mutation: MutationType!
  node: Diagram
  updatedFields: [String!]
  previousValues: DiagramPreviousValues
}

input DiagramSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiagramWhereInput
  AND: [DiagramSubscriptionWhereInput!]
  OR: [DiagramSubscriptionWhereInput!]
  NOT: [DiagramSubscriptionWhereInput!]
}

input DiagramUpdateInput {
  diagramData: Json
  ownerBO: BusinessObjectUpdateOneWithoutOwnsDiagramsInput
  participatingBOs: BusinessObjectUpdateManyWithoutParticipatesInDiagramsInput
}

input DiagramUpdateManyDataInput {
  diagramData: Json
}

input DiagramUpdateManyMutationInput {
  diagramData: Json
}

input DiagramUpdateManyWithoutOwnerBOInput {
  create: [DiagramCreateWithoutOwnerBOInput!]
  delete: [DiagramWhereUniqueInput!]
  connect: [DiagramWhereUniqueInput!]
  set: [DiagramWhereUniqueInput!]
  disconnect: [DiagramWhereUniqueInput!]
  update: [DiagramUpdateWithWhereUniqueWithoutOwnerBOInput!]
  upsert: [DiagramUpsertWithWhereUniqueWithoutOwnerBOInput!]
  deleteMany: [DiagramScalarWhereInput!]
  updateMany: [DiagramUpdateManyWithWhereNestedInput!]
}

input DiagramUpdateManyWithoutParticipatingBOsInput {
  create: [DiagramCreateWithoutParticipatingBOsInput!]
  delete: [DiagramWhereUniqueInput!]
  connect: [DiagramWhereUniqueInput!]
  set: [DiagramWhereUniqueInput!]
  disconnect: [DiagramWhereUniqueInput!]
  update: [DiagramUpdateWithWhereUniqueWithoutParticipatingBOsInput!]
  upsert: [DiagramUpsertWithWhereUniqueWithoutParticipatingBOsInput!]
  deleteMany: [DiagramScalarWhereInput!]
  updateMany: [DiagramUpdateManyWithWhereNestedInput!]
}

input DiagramUpdateManyWithWhereNestedInput {
  where: DiagramScalarWhereInput!
  data: DiagramUpdateManyDataInput!
}

input DiagramUpdateWithoutOwnerBODataInput {
  diagramData: Json
  participatingBOs: BusinessObjectUpdateManyWithoutParticipatesInDiagramsInput
}

input DiagramUpdateWithoutParticipatingBOsDataInput {
  diagramData: Json
  ownerBO: BusinessObjectUpdateOneWithoutOwnsDiagramsInput
}

input DiagramUpdateWithWhereUniqueWithoutOwnerBOInput {
  where: DiagramWhereUniqueInput!
  data: DiagramUpdateWithoutOwnerBODataInput!
}

input DiagramUpdateWithWhereUniqueWithoutParticipatingBOsInput {
  where: DiagramWhereUniqueInput!
  data: DiagramUpdateWithoutParticipatingBOsDataInput!
}

input DiagramUpsertWithWhereUniqueWithoutOwnerBOInput {
  where: DiagramWhereUniqueInput!
  update: DiagramUpdateWithoutOwnerBODataInput!
  create: DiagramCreateWithoutOwnerBOInput!
}

input DiagramUpsertWithWhereUniqueWithoutParticipatingBOsInput {
  where: DiagramWhereUniqueInput!
  update: DiagramUpdateWithoutParticipatingBOsDataInput!
  create: DiagramCreateWithoutParticipatingBOsInput!
}

input DiagramWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  ownerBO: BusinessObjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  participatingBOs_every: BusinessObjectWhereInput
  participatingBOs_some: BusinessObjectWhereInput
  participatingBOs_none: BusinessObjectWhereInput
  AND: [DiagramWhereInput!]
  OR: [DiagramWhereInput!]
  NOT: [DiagramWhereInput!]
}

input DiagramWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type MetaAttribute {
  bizAttributes(where: BizAttributeWhereInput, orderBy: BizAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizAttribute!]
  createdAt: DateTime!
  id: ID!
  name: String
  objects(where: MetaObjectWhereInput, orderBy: MetaObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaObject!]
  type: AttributeType
  updatedAt: DateTime!
}

type MetaAttributeConnection {
  pageInfo: PageInfo!
  edges: [MetaAttributeEdge]!
  aggregate: AggregateMetaAttribute!
}

input MetaAttributeCreateInput {
  bizAttributes: BizAttributeCreateManyWithoutMetaAttributeInput
  id: ID
  name: String
  objects: MetaObjectCreateManyWithoutAttributesInput
  type: AttributeType
}

input MetaAttributeCreateManyWithoutObjectsInput {
  create: [MetaAttributeCreateWithoutObjectsInput!]
  connect: [MetaAttributeWhereUniqueInput!]
}

input MetaAttributeCreateOneInput {
  create: MetaAttributeCreateInput
  connect: MetaAttributeWhereUniqueInput
}

input MetaAttributeCreateOneWithoutBizAttributesInput {
  create: MetaAttributeCreateWithoutBizAttributesInput
  connect: MetaAttributeWhereUniqueInput
}

input MetaAttributeCreateWithoutBizAttributesInput {
  id: ID
  name: String
  objects: MetaObjectCreateManyWithoutAttributesInput
  type: AttributeType
}

input MetaAttributeCreateWithoutObjectsInput {
  bizAttributes: BizAttributeCreateManyWithoutMetaAttributeInput
  id: ID
  name: String
  type: AttributeType
}

type MetaAttributeEdge {
  node: MetaAttribute!
  cursor: String!
}

enum MetaAttributeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MetaAttributePreviousValues {
  createdAt: DateTime!
  id: ID!
  name: String
  type: AttributeType
  updatedAt: DateTime!
}

input MetaAttributeScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: AttributeType
  type_not: AttributeType
  type_in: [AttributeType!]
  type_not_in: [AttributeType!]
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MetaAttributeScalarWhereInput!]
  OR: [MetaAttributeScalarWhereInput!]
  NOT: [MetaAttributeScalarWhereInput!]
}

type MetaAttributeSubscriptionPayload {
  mutation: MutationType!
  node: MetaAttribute
  updatedFields: [String!]
  previousValues: MetaAttributePreviousValues
}

input MetaAttributeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MetaAttributeWhereInput
  AND: [MetaAttributeSubscriptionWhereInput!]
  OR: [MetaAttributeSubscriptionWhereInput!]
  NOT: [MetaAttributeSubscriptionWhereInput!]
}

input MetaAttributeUpdateDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutMetaAttributeInput
  name: String
  objects: MetaObjectUpdateManyWithoutAttributesInput
  type: AttributeType
}

input MetaAttributeUpdateInput {
  bizAttributes: BizAttributeUpdateManyWithoutMetaAttributeInput
  name: String
  objects: MetaObjectUpdateManyWithoutAttributesInput
  type: AttributeType
}

input MetaAttributeUpdateManyDataInput {
  name: String
  type: AttributeType
}

input MetaAttributeUpdateManyMutationInput {
  name: String
  type: AttributeType
}

input MetaAttributeUpdateManyWithoutObjectsInput {
  create: [MetaAttributeCreateWithoutObjectsInput!]
  delete: [MetaAttributeWhereUniqueInput!]
  connect: [MetaAttributeWhereUniqueInput!]
  set: [MetaAttributeWhereUniqueInput!]
  disconnect: [MetaAttributeWhereUniqueInput!]
  update: [MetaAttributeUpdateWithWhereUniqueWithoutObjectsInput!]
  upsert: [MetaAttributeUpsertWithWhereUniqueWithoutObjectsInput!]
  deleteMany: [MetaAttributeScalarWhereInput!]
  updateMany: [MetaAttributeUpdateManyWithWhereNestedInput!]
}

input MetaAttributeUpdateManyWithWhereNestedInput {
  where: MetaAttributeScalarWhereInput!
  data: MetaAttributeUpdateManyDataInput!
}

input MetaAttributeUpdateOneInput {
  create: MetaAttributeCreateInput
  update: MetaAttributeUpdateDataInput
  upsert: MetaAttributeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaAttributeWhereUniqueInput
}

input MetaAttributeUpdateOneWithoutBizAttributesInput {
  create: MetaAttributeCreateWithoutBizAttributesInput
  update: MetaAttributeUpdateWithoutBizAttributesDataInput
  upsert: MetaAttributeUpsertWithoutBizAttributesInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaAttributeWhereUniqueInput
}

input MetaAttributeUpdateWithoutBizAttributesDataInput {
  name: String
  objects: MetaObjectUpdateManyWithoutAttributesInput
  type: AttributeType
}

input MetaAttributeUpdateWithoutObjectsDataInput {
  bizAttributes: BizAttributeUpdateManyWithoutMetaAttributeInput
  name: String
  type: AttributeType
}

input MetaAttributeUpdateWithWhereUniqueWithoutObjectsInput {
  where: MetaAttributeWhereUniqueInput!
  data: MetaAttributeUpdateWithoutObjectsDataInput!
}

input MetaAttributeUpsertNestedInput {
  update: MetaAttributeUpdateDataInput!
  create: MetaAttributeCreateInput!
}

input MetaAttributeUpsertWithoutBizAttributesInput {
  update: MetaAttributeUpdateWithoutBizAttributesDataInput!
  create: MetaAttributeCreateWithoutBizAttributesInput!
}

input MetaAttributeUpsertWithWhereUniqueWithoutObjectsInput {
  where: MetaAttributeWhereUniqueInput!
  update: MetaAttributeUpdateWithoutObjectsDataInput!
  create: MetaAttributeCreateWithoutObjectsInput!
}

input MetaAttributeWhereInput {
  bizAttributes_every: BizAttributeWhereInput
  bizAttributes_some: BizAttributeWhereInput
  bizAttributes_none: BizAttributeWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  objects_every: MetaObjectWhereInput
  objects_some: MetaObjectWhereInput
  objects_none: MetaObjectWhereInput
  type: AttributeType
  type_not: AttributeType
  type_in: [AttributeType!]
  type_not_in: [AttributeType!]
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MetaAttributeWhereInput!]
  OR: [MetaAttributeWhereInput!]
  NOT: [MetaAttributeWhereInput!]
}

input MetaAttributeWhereUniqueInput {
  id: ID
  name: String
}

type MetaObject {
  attributes(where: MetaAttributeWhereInput, orderBy: MetaAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaAttribute!]
  businessObjects(where: BusinessObjectWhereInput, orderBy: BusinessObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BusinessObject!]
  createdAt: DateTime!
  id: ID!
  incomingRelations(where: MetaRelationWhereInput, orderBy: MetaRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaRelation!]
  name: String!
  outgoingRelations(where: MetaRelationWhereInput, orderBy: MetaRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaRelation!]
  updatedAt: DateTime!
  planConfig: PlanConfig
  templateConfig: TemplateConfig
}

type MetaObjectConnection {
  pageInfo: PageInfo!
  edges: [MetaObjectEdge]!
  aggregate: AggregateMetaObject!
}

input MetaObjectCreateInput {
  attributes: MetaAttributeCreateManyWithoutObjectsInput
  businessObjects: BusinessObjectCreateManyWithoutMetaObjectInput
  id: ID
  incomingRelations: MetaRelationCreateManyWithoutOppositeObjectInput
  name: String!
  outgoingRelations: MetaRelationCreateManyWithoutIncomingObjectInput
  planConfig: PlanConfigCreateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigCreateOneWithoutMoObjectInput
}

input MetaObjectCreateManyWithoutAttributesInput {
  create: [MetaObjectCreateWithoutAttributesInput!]
  connect: [MetaObjectWhereUniqueInput!]
}

input MetaObjectCreateOneInput {
  create: MetaObjectCreateInput
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectCreateOneWithoutBusinessObjectsInput {
  create: MetaObjectCreateWithoutBusinessObjectsInput
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectCreateOneWithoutIncomingRelationsInput {
  create: MetaObjectCreateWithoutIncomingRelationsInput
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectCreateOneWithoutOutgoingRelationsInput {
  create: MetaObjectCreateWithoutOutgoingRelationsInput
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectCreateOneWithoutPlanConfigInput {
  create: MetaObjectCreateWithoutPlanConfigInput
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectCreateOneWithoutTemplateConfigInput {
  create: MetaObjectCreateWithoutTemplateConfigInput
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectCreateWithoutAttributesInput {
  businessObjects: BusinessObjectCreateManyWithoutMetaObjectInput
  id: ID
  incomingRelations: MetaRelationCreateManyWithoutOppositeObjectInput
  name: String!
  outgoingRelations: MetaRelationCreateManyWithoutIncomingObjectInput
  planConfig: PlanConfigCreateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigCreateOneWithoutMoObjectInput
}

input MetaObjectCreateWithoutBusinessObjectsInput {
  attributes: MetaAttributeCreateManyWithoutObjectsInput
  id: ID
  incomingRelations: MetaRelationCreateManyWithoutOppositeObjectInput
  name: String!
  outgoingRelations: MetaRelationCreateManyWithoutIncomingObjectInput
  planConfig: PlanConfigCreateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigCreateOneWithoutMoObjectInput
}

input MetaObjectCreateWithoutIncomingRelationsInput {
  attributes: MetaAttributeCreateManyWithoutObjectsInput
  businessObjects: BusinessObjectCreateManyWithoutMetaObjectInput
  id: ID
  name: String!
  outgoingRelations: MetaRelationCreateManyWithoutIncomingObjectInput
  planConfig: PlanConfigCreateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigCreateOneWithoutMoObjectInput
}

input MetaObjectCreateWithoutOutgoingRelationsInput {
  attributes: MetaAttributeCreateManyWithoutObjectsInput
  businessObjects: BusinessObjectCreateManyWithoutMetaObjectInput
  id: ID
  incomingRelations: MetaRelationCreateManyWithoutOppositeObjectInput
  name: String!
  planConfig: PlanConfigCreateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigCreateOneWithoutMoObjectInput
}

input MetaObjectCreateWithoutPlanConfigInput {
  attributes: MetaAttributeCreateManyWithoutObjectsInput
  businessObjects: BusinessObjectCreateManyWithoutMetaObjectInput
  id: ID
  incomingRelations: MetaRelationCreateManyWithoutOppositeObjectInput
  name: String!
  outgoingRelations: MetaRelationCreateManyWithoutIncomingObjectInput
  templateConfig: TemplateConfigCreateOneWithoutMoObjectInput
}

input MetaObjectCreateWithoutTemplateConfigInput {
  attributes: MetaAttributeCreateManyWithoutObjectsInput
  businessObjects: BusinessObjectCreateManyWithoutMetaObjectInput
  id: ID
  incomingRelations: MetaRelationCreateManyWithoutOppositeObjectInput
  name: String!
  outgoingRelations: MetaRelationCreateManyWithoutIncomingObjectInput
  planConfig: PlanConfigCreateOneWithoutUiMoPlanInput
}

type MetaObjectEdge {
  node: MetaObject!
  cursor: String!
}

enum MetaObjectOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MetaObjectPreviousValues {
  createdAt: DateTime!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

input MetaObjectScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MetaObjectScalarWhereInput!]
  OR: [MetaObjectScalarWhereInput!]
  NOT: [MetaObjectScalarWhereInput!]
}

type MetaObjectSubscriptionPayload {
  mutation: MutationType!
  node: MetaObject
  updatedFields: [String!]
  previousValues: MetaObjectPreviousValues
}

input MetaObjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MetaObjectWhereInput
  AND: [MetaObjectSubscriptionWhereInput!]
  OR: [MetaObjectSubscriptionWhereInput!]
  NOT: [MetaObjectSubscriptionWhereInput!]
}

input MetaObjectUpdateDataInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateManyDataInput {
  name: String
}

input MetaObjectUpdateManyMutationInput {
  name: String
}

input MetaObjectUpdateManyWithoutAttributesInput {
  create: [MetaObjectCreateWithoutAttributesInput!]
  delete: [MetaObjectWhereUniqueInput!]
  connect: [MetaObjectWhereUniqueInput!]
  set: [MetaObjectWhereUniqueInput!]
  disconnect: [MetaObjectWhereUniqueInput!]
  update: [MetaObjectUpdateWithWhereUniqueWithoutAttributesInput!]
  upsert: [MetaObjectUpsertWithWhereUniqueWithoutAttributesInput!]
  deleteMany: [MetaObjectScalarWhereInput!]
  updateMany: [MetaObjectUpdateManyWithWhereNestedInput!]
}

input MetaObjectUpdateManyWithWhereNestedInput {
  where: MetaObjectScalarWhereInput!
  data: MetaObjectUpdateManyDataInput!
}

input MetaObjectUpdateOneInput {
  create: MetaObjectCreateInput
  update: MetaObjectUpdateDataInput
  upsert: MetaObjectUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectUpdateOneWithoutBusinessObjectsInput {
  create: MetaObjectCreateWithoutBusinessObjectsInput
  update: MetaObjectUpdateWithoutBusinessObjectsDataInput
  upsert: MetaObjectUpsertWithoutBusinessObjectsInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectUpdateOneWithoutIncomingRelationsInput {
  create: MetaObjectCreateWithoutIncomingRelationsInput
  update: MetaObjectUpdateWithoutIncomingRelationsDataInput
  upsert: MetaObjectUpsertWithoutIncomingRelationsInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectUpdateOneWithoutOutgoingRelationsInput {
  create: MetaObjectCreateWithoutOutgoingRelationsInput
  update: MetaObjectUpdateWithoutOutgoingRelationsDataInput
  upsert: MetaObjectUpsertWithoutOutgoingRelationsInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectUpdateOneWithoutPlanConfigInput {
  create: MetaObjectCreateWithoutPlanConfigInput
  update: MetaObjectUpdateWithoutPlanConfigDataInput
  upsert: MetaObjectUpsertWithoutPlanConfigInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectUpdateOneWithoutTemplateConfigInput {
  create: MetaObjectCreateWithoutTemplateConfigInput
  update: MetaObjectUpdateWithoutTemplateConfigDataInput
  upsert: MetaObjectUpsertWithoutTemplateConfigInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaObjectWhereUniqueInput
}

input MetaObjectUpdateWithoutAttributesDataInput {
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateWithoutBusinessObjectsDataInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateWithoutIncomingRelationsDataInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateWithoutOutgoingRelationsDataInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateWithoutPlanConfigDataInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  templateConfig: TemplateConfigUpdateOneWithoutMoObjectInput
}

input MetaObjectUpdateWithoutTemplateConfigDataInput {
  attributes: MetaAttributeUpdateManyWithoutObjectsInput
  businessObjects: BusinessObjectUpdateManyWithoutMetaObjectInput
  incomingRelations: MetaRelationUpdateManyWithoutOppositeObjectInput
  name: String
  outgoingRelations: MetaRelationUpdateManyWithoutIncomingObjectInput
  planConfig: PlanConfigUpdateOneWithoutUiMoPlanInput
}

input MetaObjectUpdateWithWhereUniqueWithoutAttributesInput {
  where: MetaObjectWhereUniqueInput!
  data: MetaObjectUpdateWithoutAttributesDataInput!
}

input MetaObjectUpsertNestedInput {
  update: MetaObjectUpdateDataInput!
  create: MetaObjectCreateInput!
}

input MetaObjectUpsertWithoutBusinessObjectsInput {
  update: MetaObjectUpdateWithoutBusinessObjectsDataInput!
  create: MetaObjectCreateWithoutBusinessObjectsInput!
}

input MetaObjectUpsertWithoutIncomingRelationsInput {
  update: MetaObjectUpdateWithoutIncomingRelationsDataInput!
  create: MetaObjectCreateWithoutIncomingRelationsInput!
}

input MetaObjectUpsertWithoutOutgoingRelationsInput {
  update: MetaObjectUpdateWithoutOutgoingRelationsDataInput!
  create: MetaObjectCreateWithoutOutgoingRelationsInput!
}

input MetaObjectUpsertWithoutPlanConfigInput {
  update: MetaObjectUpdateWithoutPlanConfigDataInput!
  create: MetaObjectCreateWithoutPlanConfigInput!
}

input MetaObjectUpsertWithoutTemplateConfigInput {
  update: MetaObjectUpdateWithoutTemplateConfigDataInput!
  create: MetaObjectCreateWithoutTemplateConfigInput!
}

input MetaObjectUpsertWithWhereUniqueWithoutAttributesInput {
  where: MetaObjectWhereUniqueInput!
  update: MetaObjectUpdateWithoutAttributesDataInput!
  create: MetaObjectCreateWithoutAttributesInput!
}

input MetaObjectWhereInput {
  attributes_every: MetaAttributeWhereInput
  attributes_some: MetaAttributeWhereInput
  attributes_none: MetaAttributeWhereInput
  businessObjects_every: BusinessObjectWhereInput
  businessObjects_some: BusinessObjectWhereInput
  businessObjects_none: BusinessObjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  incomingRelations_every: MetaRelationWhereInput
  incomingRelations_some: MetaRelationWhereInput
  incomingRelations_none: MetaRelationWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  outgoingRelations_every: MetaRelationWhereInput
  outgoingRelations_some: MetaRelationWhereInput
  outgoingRelations_none: MetaRelationWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  planConfig: PlanConfigWhereInput
  templateConfig: TemplateConfigWhereInput
  AND: [MetaObjectWhereInput!]
  OR: [MetaObjectWhereInput!]
  NOT: [MetaObjectWhereInput!]
}

input MetaObjectWhereUniqueInput {
  id: ID
}

type MetaRelation {
  bizRelations(where: BizRelationWhereInput, orderBy: BizRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizRelation!]
  createdAt: DateTime!
  id: ID!
  incomingObject: MetaObject
  multiplicity: MultiplicityType!
  oppositeName: String!
  oppositeObject: MetaObject
  oppositeRelation: MetaRelation
  updatedAt: DateTime!
}

type MetaRelationConnection {
  pageInfo: PageInfo!
  edges: [MetaRelationEdge]!
  aggregate: AggregateMetaRelation!
}

input MetaRelationCreateInput {
  bizRelations: BizRelationCreateManyWithoutMetaRelationInput
  id: ID
  incomingObject: MetaObjectCreateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType!
  oppositeName: String!
  oppositeObject: MetaObjectCreateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationCreateOneWithoutOppositeRelationInput
}

input MetaRelationCreateManyInput {
  create: [MetaRelationCreateInput!]
  connect: [MetaRelationWhereUniqueInput!]
}

input MetaRelationCreateManyWithoutIncomingObjectInput {
  create: [MetaRelationCreateWithoutIncomingObjectInput!]
  connect: [MetaRelationWhereUniqueInput!]
}

input MetaRelationCreateManyWithoutOppositeObjectInput {
  create: [MetaRelationCreateWithoutOppositeObjectInput!]
  connect: [MetaRelationWhereUniqueInput!]
}

input MetaRelationCreateOneInput {
  create: MetaRelationCreateInput
  connect: MetaRelationWhereUniqueInput
}

input MetaRelationCreateOneWithoutBizRelationsInput {
  create: MetaRelationCreateWithoutBizRelationsInput
  connect: MetaRelationWhereUniqueInput
}

input MetaRelationCreateOneWithoutOppositeRelationInput {
  create: MetaRelationCreateWithoutOppositeRelationInput
  connect: MetaRelationWhereUniqueInput
}

input MetaRelationCreateWithoutBizRelationsInput {
  id: ID
  incomingObject: MetaObjectCreateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType!
  oppositeName: String!
  oppositeObject: MetaObjectCreateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationCreateOneWithoutOppositeRelationInput
}

input MetaRelationCreateWithoutIncomingObjectInput {
  bizRelations: BizRelationCreateManyWithoutMetaRelationInput
  id: ID
  multiplicity: MultiplicityType!
  oppositeName: String!
  oppositeObject: MetaObjectCreateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationCreateOneWithoutOppositeRelationInput
}

input MetaRelationCreateWithoutOppositeObjectInput {
  bizRelations: BizRelationCreateManyWithoutMetaRelationInput
  id: ID
  incomingObject: MetaObjectCreateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType!
  oppositeName: String!
  oppositeRelation: MetaRelationCreateOneWithoutOppositeRelationInput
}

input MetaRelationCreateWithoutOppositeRelationInput {
  bizRelations: BizRelationCreateManyWithoutMetaRelationInput
  id: ID
  incomingObject: MetaObjectCreateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType!
  oppositeName: String!
  oppositeObject: MetaObjectCreateOneWithoutIncomingRelationsInput
}

type MetaRelationEdge {
  node: MetaRelation!
  cursor: String!
}

enum MetaRelationOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  multiplicity_ASC
  multiplicity_DESC
  oppositeName_ASC
  oppositeName_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MetaRelationPreviousValues {
  createdAt: DateTime!
  id: ID!
  multiplicity: MultiplicityType!
  oppositeName: String!
  updatedAt: DateTime!
}

input MetaRelationScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  multiplicity: MultiplicityType
  multiplicity_not: MultiplicityType
  multiplicity_in: [MultiplicityType!]
  multiplicity_not_in: [MultiplicityType!]
  oppositeName: String
  oppositeName_not: String
  oppositeName_in: [String!]
  oppositeName_not_in: [String!]
  oppositeName_lt: String
  oppositeName_lte: String
  oppositeName_gt: String
  oppositeName_gte: String
  oppositeName_contains: String
  oppositeName_not_contains: String
  oppositeName_starts_with: String
  oppositeName_not_starts_with: String
  oppositeName_ends_with: String
  oppositeName_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MetaRelationScalarWhereInput!]
  OR: [MetaRelationScalarWhereInput!]
  NOT: [MetaRelationScalarWhereInput!]
}

type MetaRelationSubscriptionPayload {
  mutation: MutationType!
  node: MetaRelation
  updatedFields: [String!]
  previousValues: MetaRelationPreviousValues
}

input MetaRelationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MetaRelationWhereInput
  AND: [MetaRelationSubscriptionWhereInput!]
  OR: [MetaRelationSubscriptionWhereInput!]
  NOT: [MetaRelationSubscriptionWhereInput!]
}

input MetaRelationUpdateDataInput {
  bizRelations: BizRelationUpdateManyWithoutMetaRelationInput
  incomingObject: MetaObjectUpdateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType
  oppositeName: String
  oppositeObject: MetaObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationUpdateOneWithoutOppositeRelationInput
}

input MetaRelationUpdateInput {
  bizRelations: BizRelationUpdateManyWithoutMetaRelationInput
  incomingObject: MetaObjectUpdateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType
  oppositeName: String
  oppositeObject: MetaObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationUpdateOneWithoutOppositeRelationInput
}

input MetaRelationUpdateManyDataInput {
  multiplicity: MultiplicityType
  oppositeName: String
}

input MetaRelationUpdateManyInput {
  create: [MetaRelationCreateInput!]
  update: [MetaRelationUpdateWithWhereUniqueNestedInput!]
  upsert: [MetaRelationUpsertWithWhereUniqueNestedInput!]
  delete: [MetaRelationWhereUniqueInput!]
  connect: [MetaRelationWhereUniqueInput!]
  set: [MetaRelationWhereUniqueInput!]
  disconnect: [MetaRelationWhereUniqueInput!]
  deleteMany: [MetaRelationScalarWhereInput!]
  updateMany: [MetaRelationUpdateManyWithWhereNestedInput!]
}

input MetaRelationUpdateManyMutationInput {
  multiplicity: MultiplicityType
  oppositeName: String
}

input MetaRelationUpdateManyWithoutIncomingObjectInput {
  create: [MetaRelationCreateWithoutIncomingObjectInput!]
  delete: [MetaRelationWhereUniqueInput!]
  connect: [MetaRelationWhereUniqueInput!]
  set: [MetaRelationWhereUniqueInput!]
  disconnect: [MetaRelationWhereUniqueInput!]
  update: [MetaRelationUpdateWithWhereUniqueWithoutIncomingObjectInput!]
  upsert: [MetaRelationUpsertWithWhereUniqueWithoutIncomingObjectInput!]
  deleteMany: [MetaRelationScalarWhereInput!]
  updateMany: [MetaRelationUpdateManyWithWhereNestedInput!]
}

input MetaRelationUpdateManyWithoutOppositeObjectInput {
  create: [MetaRelationCreateWithoutOppositeObjectInput!]
  delete: [MetaRelationWhereUniqueInput!]
  connect: [MetaRelationWhereUniqueInput!]
  set: [MetaRelationWhereUniqueInput!]
  disconnect: [MetaRelationWhereUniqueInput!]
  update: [MetaRelationUpdateWithWhereUniqueWithoutOppositeObjectInput!]
  upsert: [MetaRelationUpsertWithWhereUniqueWithoutOppositeObjectInput!]
  deleteMany: [MetaRelationScalarWhereInput!]
  updateMany: [MetaRelationUpdateManyWithWhereNestedInput!]
}

input MetaRelationUpdateManyWithWhereNestedInput {
  where: MetaRelationScalarWhereInput!
  data: MetaRelationUpdateManyDataInput!
}

input MetaRelationUpdateOneInput {
  create: MetaRelationCreateInput
  update: MetaRelationUpdateDataInput
  upsert: MetaRelationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaRelationWhereUniqueInput
}

input MetaRelationUpdateOneWithoutBizRelationsInput {
  create: MetaRelationCreateWithoutBizRelationsInput
  update: MetaRelationUpdateWithoutBizRelationsDataInput
  upsert: MetaRelationUpsertWithoutBizRelationsInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaRelationWhereUniqueInput
}

input MetaRelationUpdateOneWithoutOppositeRelationInput {
  create: MetaRelationCreateWithoutOppositeRelationInput
  update: MetaRelationUpdateWithoutOppositeRelationDataInput
  upsert: MetaRelationUpsertWithoutOppositeRelationInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaRelationWhereUniqueInput
}

input MetaRelationUpdateWithoutBizRelationsDataInput {
  incomingObject: MetaObjectUpdateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType
  oppositeName: String
  oppositeObject: MetaObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationUpdateOneWithoutOppositeRelationInput
}

input MetaRelationUpdateWithoutIncomingObjectDataInput {
  bizRelations: BizRelationUpdateManyWithoutMetaRelationInput
  multiplicity: MultiplicityType
  oppositeName: String
  oppositeObject: MetaObjectUpdateOneWithoutIncomingRelationsInput
  oppositeRelation: MetaRelationUpdateOneWithoutOppositeRelationInput
}

input MetaRelationUpdateWithoutOppositeObjectDataInput {
  bizRelations: BizRelationUpdateManyWithoutMetaRelationInput
  incomingObject: MetaObjectUpdateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType
  oppositeName: String
  oppositeRelation: MetaRelationUpdateOneWithoutOppositeRelationInput
}

input MetaRelationUpdateWithoutOppositeRelationDataInput {
  bizRelations: BizRelationUpdateManyWithoutMetaRelationInput
  incomingObject: MetaObjectUpdateOneWithoutOutgoingRelationsInput
  multiplicity: MultiplicityType
  oppositeName: String
  oppositeObject: MetaObjectUpdateOneWithoutIncomingRelationsInput
}

input MetaRelationUpdateWithWhereUniqueNestedInput {
  where: MetaRelationWhereUniqueInput!
  data: MetaRelationUpdateDataInput!
}

input MetaRelationUpdateWithWhereUniqueWithoutIncomingObjectInput {
  where: MetaRelationWhereUniqueInput!
  data: MetaRelationUpdateWithoutIncomingObjectDataInput!
}

input MetaRelationUpdateWithWhereUniqueWithoutOppositeObjectInput {
  where: MetaRelationWhereUniqueInput!
  data: MetaRelationUpdateWithoutOppositeObjectDataInput!
}

input MetaRelationUpsertNestedInput {
  update: MetaRelationUpdateDataInput!
  create: MetaRelationCreateInput!
}

input MetaRelationUpsertWithoutBizRelationsInput {
  update: MetaRelationUpdateWithoutBizRelationsDataInput!
  create: MetaRelationCreateWithoutBizRelationsInput!
}

input MetaRelationUpsertWithoutOppositeRelationInput {
  update: MetaRelationUpdateWithoutOppositeRelationDataInput!
  create: MetaRelationCreateWithoutOppositeRelationInput!
}

input MetaRelationUpsertWithWhereUniqueNestedInput {
  where: MetaRelationWhereUniqueInput!
  update: MetaRelationUpdateDataInput!
  create: MetaRelationCreateInput!
}

input MetaRelationUpsertWithWhereUniqueWithoutIncomingObjectInput {
  where: MetaRelationWhereUniqueInput!
  update: MetaRelationUpdateWithoutIncomingObjectDataInput!
  create: MetaRelationCreateWithoutIncomingObjectInput!
}

input MetaRelationUpsertWithWhereUniqueWithoutOppositeObjectInput {
  where: MetaRelationWhereUniqueInput!
  update: MetaRelationUpdateWithoutOppositeObjectDataInput!
  create: MetaRelationCreateWithoutOppositeObjectInput!
}

input MetaRelationWhereInput {
  bizRelations_every: BizRelationWhereInput
  bizRelations_some: BizRelationWhereInput
  bizRelations_none: BizRelationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  incomingObject: MetaObjectWhereInput
  multiplicity: MultiplicityType
  multiplicity_not: MultiplicityType
  multiplicity_in: [MultiplicityType!]
  multiplicity_not_in: [MultiplicityType!]
  oppositeName: String
  oppositeName_not: String
  oppositeName_in: [String!]
  oppositeName_not_in: [String!]
  oppositeName_lt: String
  oppositeName_lte: String
  oppositeName_gt: String
  oppositeName_gte: String
  oppositeName_contains: String
  oppositeName_not_contains: String
  oppositeName_starts_with: String
  oppositeName_not_starts_with: String
  oppositeName_ends_with: String
  oppositeName_not_ends_with: String
  oppositeObject: MetaObjectWhereInput
  oppositeRelation: MetaRelationWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MetaRelationWhereInput!]
  OR: [MetaRelationWhereInput!]
  NOT: [MetaRelationWhereInput!]
}

input MetaRelationWhereUniqueInput {
  id: ID
}

enum MultiplicityType {
  One
  Many
}

type Mutation {
  createBizAttribute(data: BizAttributeCreateInput!): BizAttribute!
  updateBizAttribute(data: BizAttributeUpdateInput!, where: BizAttributeWhereUniqueInput!): BizAttribute
  updateManyBizAttributes(data: BizAttributeUpdateManyMutationInput!, where: BizAttributeWhereInput): BatchPayload!
  upsertBizAttribute(where: BizAttributeWhereUniqueInput!, create: BizAttributeCreateInput!, update: BizAttributeUpdateInput!): BizAttribute!
  deleteBizAttribute(where: BizAttributeWhereUniqueInput!): BizAttribute
  deleteManyBizAttributes(where: BizAttributeWhereInput): BatchPayload!
  createBizRelation(data: BizRelationCreateInput!): BizRelation!
  updateBizRelation(data: BizRelationUpdateInput!, where: BizRelationWhereUniqueInput!): BizRelation
  upsertBizRelation(where: BizRelationWhereUniqueInput!, create: BizRelationCreateInput!, update: BizRelationUpdateInput!): BizRelation!
  deleteBizRelation(where: BizRelationWhereUniqueInput!): BizRelation
  deleteManyBizRelations(where: BizRelationWhereInput): BatchPayload!
  createBusinessObject(data: BusinessObjectCreateInput!): BusinessObject!
  updateBusinessObject(data: BusinessObjectUpdateInput!, where: BusinessObjectWhereUniqueInput!): BusinessObject
  updateManyBusinessObjects(data: BusinessObjectUpdateManyMutationInput!, where: BusinessObjectWhereInput): BatchPayload!
  upsertBusinessObject(where: BusinessObjectWhereUniqueInput!, create: BusinessObjectCreateInput!, update: BusinessObjectUpdateInput!): BusinessObject!
  deleteBusinessObject(where: BusinessObjectWhereUniqueInput!): BusinessObject
  deleteManyBusinessObjects(where: BusinessObjectWhereInput): BatchPayload!
  createDiagram(data: DiagramCreateInput!): Diagram!
  updateDiagram(data: DiagramUpdateInput!, where: DiagramWhereUniqueInput!): Diagram
  updateManyDiagrams(data: DiagramUpdateManyMutationInput!, where: DiagramWhereInput): BatchPayload!
  upsertDiagram(where: DiagramWhereUniqueInput!, create: DiagramCreateInput!, update: DiagramUpdateInput!): Diagram!
  deleteDiagram(where: DiagramWhereUniqueInput!): Diagram
  deleteManyDiagrams(where: DiagramWhereInput): BatchPayload!
  createMetaAttribute(data: MetaAttributeCreateInput!): MetaAttribute!
  updateMetaAttribute(data: MetaAttributeUpdateInput!, where: MetaAttributeWhereUniqueInput!): MetaAttribute
  updateManyMetaAttributes(data: MetaAttributeUpdateManyMutationInput!, where: MetaAttributeWhereInput): BatchPayload!
  upsertMetaAttribute(where: MetaAttributeWhereUniqueInput!, create: MetaAttributeCreateInput!, update: MetaAttributeUpdateInput!): MetaAttribute!
  deleteMetaAttribute(where: MetaAttributeWhereUniqueInput!): MetaAttribute
  deleteManyMetaAttributes(where: MetaAttributeWhereInput): BatchPayload!
  createMetaObject(data: MetaObjectCreateInput!): MetaObject!
  updateMetaObject(data: MetaObjectUpdateInput!, where: MetaObjectWhereUniqueInput!): MetaObject
  updateManyMetaObjects(data: MetaObjectUpdateManyMutationInput!, where: MetaObjectWhereInput): BatchPayload!
  upsertMetaObject(where: MetaObjectWhereUniqueInput!, create: MetaObjectCreateInput!, update: MetaObjectUpdateInput!): MetaObject!
  deleteMetaObject(where: MetaObjectWhereUniqueInput!): MetaObject
  deleteManyMetaObjects(where: MetaObjectWhereInput): BatchPayload!
  createMetaRelation(data: MetaRelationCreateInput!): MetaRelation!
  updateMetaRelation(data: MetaRelationUpdateInput!, where: MetaRelationWhereUniqueInput!): MetaRelation
  updateManyMetaRelations(data: MetaRelationUpdateManyMutationInput!, where: MetaRelationWhereInput): BatchPayload!
  upsertMetaRelation(where: MetaRelationWhereUniqueInput!, create: MetaRelationCreateInput!, update: MetaRelationUpdateInput!): MetaRelation!
  deleteMetaRelation(where: MetaRelationWhereUniqueInput!): MetaRelation
  deleteManyMetaRelations(where: MetaRelationWhereInput): BatchPayload!
  createPlan(data: PlanCreateInput!): Plan!
  updatePlan(data: PlanUpdateInput!, where: PlanWhereUniqueInput!): Plan
  updateManyPlans(data: PlanUpdateManyMutationInput!, where: PlanWhereInput): BatchPayload!
  upsertPlan(where: PlanWhereUniqueInput!, create: PlanCreateInput!, update: PlanUpdateInput!): Plan!
  deletePlan(where: PlanWhereUniqueInput!): Plan
  deleteManyPlans(where: PlanWhereInput): BatchPayload!
  createPlanConfig(data: PlanConfigCreateInput!): PlanConfig!
  updatePlanConfig(data: PlanConfigUpdateInput!, where: PlanConfigWhereUniqueInput!): PlanConfig
  upsertPlanConfig(where: PlanConfigWhereUniqueInput!, create: PlanConfigCreateInput!, update: PlanConfigUpdateInput!): PlanConfig!
  deletePlanConfig(where: PlanConfigWhereUniqueInput!): PlanConfig
  deleteManyPlanConfigs(where: PlanConfigWhereInput): BatchPayload!
  createRenderColumn(data: RenderColumnCreateInput!): RenderColumn!
  updateRenderColumn(data: RenderColumnUpdateInput!, where: RenderColumnWhereUniqueInput!): RenderColumn
  updateManyRenderColumns(data: RenderColumnUpdateManyMutationInput!, where: RenderColumnWhereInput): BatchPayload!
  upsertRenderColumn(where: RenderColumnWhereUniqueInput!, create: RenderColumnCreateInput!, update: RenderColumnUpdateInput!): RenderColumn!
  deleteRenderColumn(where: RenderColumnWhereUniqueInput!): RenderColumn
  deleteManyRenderColumns(where: RenderColumnWhereInput): BatchPayload!
  createSMTransition(data: SMTransitionCreateInput!): SMTransition!
  updateSMTransition(data: SMTransitionUpdateInput!, where: SMTransitionWhereUniqueInput!): SMTransition
  updateManySMTransitions(data: SMTransitionUpdateManyMutationInput!, where: SMTransitionWhereInput): BatchPayload!
  upsertSMTransition(where: SMTransitionWhereUniqueInput!, create: SMTransitionCreateInput!, update: SMTransitionUpdateInput!): SMTransition!
  deleteSMTransition(where: SMTransitionWhereUniqueInput!): SMTransition
  deleteManySMTransitions(where: SMTransitionWhereInput): BatchPayload!
  createStateMachineSchema(data: StateMachineSchemaCreateInput!): StateMachineSchema!
  updateStateMachineSchema(data: StateMachineSchemaUpdateInput!, where: StateMachineSchemaWhereUniqueInput!): StateMachineSchema
  updateManyStateMachineSchemas(data: StateMachineSchemaUpdateManyMutationInput!, where: StateMachineSchemaWhereInput): BatchPayload!
  upsertStateMachineSchema(where: StateMachineSchemaWhereUniqueInput!, create: StateMachineSchemaCreateInput!, update: StateMachineSchemaUpdateInput!): StateMachineSchema!
  deleteStateMachineSchema(where: StateMachineSchemaWhereUniqueInput!): StateMachineSchema
  deleteManyStateMachineSchemas(where: StateMachineSchemaWhereInput): BatchPayload!
  createSystemSetup(data: SystemSetupCreateInput!): SystemSetup!
  updateSystemSetup(data: SystemSetupUpdateInput!, where: SystemSetupWhereUniqueInput!): SystemSetup
  upsertSystemSetup(where: SystemSetupWhereUniqueInput!, create: SystemSetupCreateInput!, update: SystemSetupUpdateInput!): SystemSetup!
  deleteSystemSetup(where: SystemSetupWhereUniqueInput!): SystemSetup
  deleteManySystemSetups(where: SystemSetupWhereInput): BatchPayload!
  createTemplate(data: TemplateCreateInput!): Template!
  updateTemplate(data: TemplateUpdateInput!, where: TemplateWhereUniqueInput!): Template
  updateManyTemplates(data: TemplateUpdateManyMutationInput!, where: TemplateWhereInput): BatchPayload!
  upsertTemplate(where: TemplateWhereUniqueInput!, create: TemplateCreateInput!, update: TemplateUpdateInput!): Template!
  deleteTemplate(where: TemplateWhereUniqueInput!): Template
  deleteManyTemplates(where: TemplateWhereInput): BatchPayload!
  createTemplateConfig(data: TemplateConfigCreateInput!): TemplateConfig!
  updateTemplateConfig(data: TemplateConfigUpdateInput!, where: TemplateConfigWhereUniqueInput!): TemplateConfig
  updateManyTemplateConfigs(data: TemplateConfigUpdateManyMutationInput!, where: TemplateConfigWhereInput): BatchPayload!
  upsertTemplateConfig(where: TemplateConfigWhereUniqueInput!, create: TemplateConfigCreateInput!, update: TemplateConfigUpdateInput!): TemplateConfig!
  deleteTemplateConfig(where: TemplateConfigWhereUniqueInput!): TemplateConfig
  deleteManyTemplateConfigs(where: TemplateConfigWhereInput): BatchPayload!
  createTemplateMapping(data: TemplateMappingCreateInput!): TemplateMapping!
  updateTemplateMapping(data: TemplateMappingUpdateInput!, where: TemplateMappingWhereUniqueInput!): TemplateMapping
  upsertTemplateMapping(where: TemplateMappingWhereUniqueInput!, create: TemplateMappingCreateInput!, update: TemplateMappingUpdateInput!): TemplateMapping!
  deleteTemplateMapping(where: TemplateMappingWhereUniqueInput!): TemplateMapping
  deleteManyTemplateMappings(where: TemplateMappingWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWidget(data: WidgetCreateInput!): Widget!
  updateWidget(data: WidgetUpdateInput!, where: WidgetWhereUniqueInput!): Widget
  updateManyWidgets(data: WidgetUpdateManyMutationInput!, where: WidgetWhereInput): BatchPayload!
  upsertWidget(where: WidgetWhereUniqueInput!, create: WidgetCreateInput!, update: WidgetUpdateInput!): Widget!
  deleteWidget(where: WidgetWhereUniqueInput!): Widget
  deleteManyWidgets(where: WidgetWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Plan {
  id: ID!
  planData: Json
  planBO: BusinessObject
  createdAt: DateTime!
  updatedAt: DateTime!
  itemBOs(where: BusinessObjectWhereInput, orderBy: BusinessObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BusinessObject!]
}

type PlanConfig {
  id: ID!
  uiMoPlan: MetaObject
  uiMoRelations(where: MetaRelationWhereInput, orderBy: MetaRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaRelation!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PlanConfigConnection {
  pageInfo: PageInfo!
  edges: [PlanConfigEdge]!
  aggregate: AggregatePlanConfig!
}

input PlanConfigCreateInput {
  id: ID
  uiMoPlan: MetaObjectCreateOneWithoutPlanConfigInput
  uiMoRelations: MetaRelationCreateManyInput
}

input PlanConfigCreateOneWithoutUiMoPlanInput {
  create: PlanConfigCreateWithoutUiMoPlanInput
  connect: PlanConfigWhereUniqueInput
}

input PlanConfigCreateWithoutUiMoPlanInput {
  id: ID
  uiMoRelations: MetaRelationCreateManyInput
}

type PlanConfigEdge {
  node: PlanConfig!
  cursor: String!
}

enum PlanConfigOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PlanConfigPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PlanConfigSubscriptionPayload {
  mutation: MutationType!
  node: PlanConfig
  updatedFields: [String!]
  previousValues: PlanConfigPreviousValues
}

input PlanConfigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlanConfigWhereInput
  AND: [PlanConfigSubscriptionWhereInput!]
  OR: [PlanConfigSubscriptionWhereInput!]
  NOT: [PlanConfigSubscriptionWhereInput!]
}

input PlanConfigUpdateInput {
  uiMoPlan: MetaObjectUpdateOneWithoutPlanConfigInput
  uiMoRelations: MetaRelationUpdateManyInput
}

input PlanConfigUpdateOneWithoutUiMoPlanInput {
  create: PlanConfigCreateWithoutUiMoPlanInput
  update: PlanConfigUpdateWithoutUiMoPlanDataInput
  upsert: PlanConfigUpsertWithoutUiMoPlanInput
  delete: Boolean
  disconnect: Boolean
  connect: PlanConfigWhereUniqueInput
}

input PlanConfigUpdateWithoutUiMoPlanDataInput {
  uiMoRelations: MetaRelationUpdateManyInput
}

input PlanConfigUpsertWithoutUiMoPlanInput {
  update: PlanConfigUpdateWithoutUiMoPlanDataInput!
  create: PlanConfigCreateWithoutUiMoPlanInput!
}

input PlanConfigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  uiMoPlan: MetaObjectWhereInput
  uiMoRelations_every: MetaRelationWhereInput
  uiMoRelations_some: MetaRelationWhereInput
  uiMoRelations_none: MetaRelationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PlanConfigWhereInput!]
  OR: [PlanConfigWhereInput!]
  NOT: [PlanConfigWhereInput!]
}

input PlanConfigWhereUniqueInput {
  id: ID
}

type PlanConnection {
  pageInfo: PageInfo!
  edges: [PlanEdge]!
  aggregate: AggregatePlan!
}

input PlanCreateInput {
  id: ID
  planData: Json
  planBO: BusinessObjectCreateOneWithoutPlanInput
  itemBOs: BusinessObjectCreateManyWithoutPlannedInInput
}

input PlanCreateOneWithoutItemBOsInput {
  create: PlanCreateWithoutItemBOsInput
  connect: PlanWhereUniqueInput
}

input PlanCreateOneWithoutPlanBOInput {
  create: PlanCreateWithoutPlanBOInput
  connect: PlanWhereUniqueInput
}

input PlanCreateWithoutItemBOsInput {
  id: ID
  planData: Json
  planBO: BusinessObjectCreateOneWithoutPlanInput
}

input PlanCreateWithoutPlanBOInput {
  id: ID
  planData: Json
  itemBOs: BusinessObjectCreateManyWithoutPlannedInInput
}

type PlanEdge {
  node: Plan!
  cursor: String!
}

enum PlanOrderByInput {
  id_ASC
  id_DESC
  planData_ASC
  planData_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PlanPreviousValues {
  id: ID!
  planData: Json
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PlanSubscriptionPayload {
  mutation: MutationType!
  node: Plan
  updatedFields: [String!]
  previousValues: PlanPreviousValues
}

input PlanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlanWhereInput
  AND: [PlanSubscriptionWhereInput!]
  OR: [PlanSubscriptionWhereInput!]
  NOT: [PlanSubscriptionWhereInput!]
}

input PlanUpdateInput {
  planData: Json
  planBO: BusinessObjectUpdateOneWithoutPlanInput
  itemBOs: BusinessObjectUpdateManyWithoutPlannedInInput
}

input PlanUpdateManyMutationInput {
  planData: Json
}

input PlanUpdateOneWithoutItemBOsInput {
  create: PlanCreateWithoutItemBOsInput
  update: PlanUpdateWithoutItemBOsDataInput
  upsert: PlanUpsertWithoutItemBOsInput
  delete: Boolean
  disconnect: Boolean
  connect: PlanWhereUniqueInput
}

input PlanUpdateOneWithoutPlanBOInput {
  create: PlanCreateWithoutPlanBOInput
  update: PlanUpdateWithoutPlanBODataInput
  upsert: PlanUpsertWithoutPlanBOInput
  delete: Boolean
  disconnect: Boolean
  connect: PlanWhereUniqueInput
}

input PlanUpdateWithoutItemBOsDataInput {
  planData: Json
  planBO: BusinessObjectUpdateOneWithoutPlanInput
}

input PlanUpdateWithoutPlanBODataInput {
  planData: Json
  itemBOs: BusinessObjectUpdateManyWithoutPlannedInInput
}

input PlanUpsertWithoutItemBOsInput {
  update: PlanUpdateWithoutItemBOsDataInput!
  create: PlanCreateWithoutItemBOsInput!
}

input PlanUpsertWithoutPlanBOInput {
  update: PlanUpdateWithoutPlanBODataInput!
  create: PlanCreateWithoutPlanBOInput!
}

input PlanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  planBO: BusinessObjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  itemBOs_every: BusinessObjectWhereInput
  itemBOs_some: BusinessObjectWhereInput
  itemBOs_none: BusinessObjectWhereInput
  AND: [PlanWhereInput!]
  OR: [PlanWhereInput!]
  NOT: [PlanWhereInput!]
}

input PlanWhereUniqueInput {
  id: ID
}

type Query {
  bizAttribute(where: BizAttributeWhereUniqueInput!): BizAttribute
  bizAttributes(where: BizAttributeWhereInput, orderBy: BizAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizAttribute]!
  bizAttributesConnection(where: BizAttributeWhereInput, orderBy: BizAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BizAttributeConnection!
  bizRelation(where: BizRelationWhereUniqueInput!): BizRelation
  bizRelations(where: BizRelationWhereInput, orderBy: BizRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BizRelation]!
  bizRelationsConnection(where: BizRelationWhereInput, orderBy: BizRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BizRelationConnection!
  businessObject(where: BusinessObjectWhereUniqueInput!): BusinessObject
  businessObjects(where: BusinessObjectWhereInput, orderBy: BusinessObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BusinessObject]!
  businessObjectsConnection(where: BusinessObjectWhereInput, orderBy: BusinessObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BusinessObjectConnection!
  diagram(where: DiagramWhereUniqueInput!): Diagram
  diagrams(where: DiagramWhereInput, orderBy: DiagramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Diagram]!
  diagramsConnection(where: DiagramWhereInput, orderBy: DiagramOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiagramConnection!
  metaAttribute(where: MetaAttributeWhereUniqueInput!): MetaAttribute
  metaAttributes(where: MetaAttributeWhereInput, orderBy: MetaAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaAttribute]!
  metaAttributesConnection(where: MetaAttributeWhereInput, orderBy: MetaAttributeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MetaAttributeConnection!
  metaObject(where: MetaObjectWhereUniqueInput!): MetaObject
  metaObjects(where: MetaObjectWhereInput, orderBy: MetaObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaObject]!
  metaObjectsConnection(where: MetaObjectWhereInput, orderBy: MetaObjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MetaObjectConnection!
  metaRelation(where: MetaRelationWhereUniqueInput!): MetaRelation
  metaRelations(where: MetaRelationWhereInput, orderBy: MetaRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaRelation]!
  metaRelationsConnection(where: MetaRelationWhereInput, orderBy: MetaRelationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MetaRelationConnection!
  plan(where: PlanWhereUniqueInput!): Plan
  plans(where: PlanWhereInput, orderBy: PlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Plan]!
  plansConnection(where: PlanWhereInput, orderBy: PlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlanConnection!
  planConfig(where: PlanConfigWhereUniqueInput!): PlanConfig
  planConfigs(where: PlanConfigWhereInput, orderBy: PlanConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PlanConfig]!
  planConfigsConnection(where: PlanConfigWhereInput, orderBy: PlanConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlanConfigConnection!
  renderColumn(where: RenderColumnWhereUniqueInput!): RenderColumn
  renderColumns(where: RenderColumnWhereInput, orderBy: RenderColumnOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RenderColumn]!
  renderColumnsConnection(where: RenderColumnWhereInput, orderBy: RenderColumnOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RenderColumnConnection!
  sMTransition(where: SMTransitionWhereUniqueInput!): SMTransition
  sMTransitions(where: SMTransitionWhereInput, orderBy: SMTransitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SMTransition]!
  sMTransitionsConnection(where: SMTransitionWhereInput, orderBy: SMTransitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SMTransitionConnection!
  stateMachineSchema(where: StateMachineSchemaWhereUniqueInput!): StateMachineSchema
  stateMachineSchemas(where: StateMachineSchemaWhereInput, orderBy: StateMachineSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StateMachineSchema]!
  stateMachineSchemasConnection(where: StateMachineSchemaWhereInput, orderBy: StateMachineSchemaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StateMachineSchemaConnection!
  systemSetup(where: SystemSetupWhereUniqueInput!): SystemSetup
  systemSetups(where: SystemSetupWhereInput, orderBy: SystemSetupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SystemSetup]!
  systemSetupsConnection(where: SystemSetupWhereInput, orderBy: SystemSetupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SystemSetupConnection!
  template(where: TemplateWhereUniqueInput!): Template
  templates(where: TemplateWhereInput, orderBy: TemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Template]!
  templatesConnection(where: TemplateWhereInput, orderBy: TemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemplateConnection!
  templateConfig(where: TemplateConfigWhereUniqueInput!): TemplateConfig
  templateConfigs(where: TemplateConfigWhereInput, orderBy: TemplateConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TemplateConfig]!
  templateConfigsConnection(where: TemplateConfigWhereInput, orderBy: TemplateConfigOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemplateConfigConnection!
  templateMapping(where: TemplateMappingWhereUniqueInput!): TemplateMapping
  templateMappings(where: TemplateMappingWhereInput, orderBy: TemplateMappingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TemplateMapping]!
  templateMappingsConnection(where: TemplateMappingWhereInput, orderBy: TemplateMappingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TemplateMappingConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  widget(where: WidgetWhereUniqueInput!): Widget
  widgets(where: WidgetWhereInput, orderBy: WidgetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Widget]!
  widgetsConnection(where: WidgetWhereInput, orderBy: WidgetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WidgetConnection!
  node(id: ID!): Node
}

type RenderColumn {
  id: ID!
  widgets(where: WidgetWhereInput, orderBy: WidgetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Widget!]
  width: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RenderColumnConnection {
  pageInfo: PageInfo!
  edges: [RenderColumnEdge]!
  aggregate: AggregateRenderColumn!
}

input RenderColumnCreateInput {
  id: ID
  widgets: WidgetCreateManyInput
  width: Int
}

input RenderColumnCreateManyInput {
  create: [RenderColumnCreateInput!]
  connect: [RenderColumnWhereUniqueInput!]
}

type RenderColumnEdge {
  node: RenderColumn!
  cursor: String!
}

enum RenderColumnOrderByInput {
  id_ASC
  id_DESC
  width_ASC
  width_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RenderColumnPreviousValues {
  id: ID!
  width: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

input RenderColumnScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RenderColumnScalarWhereInput!]
  OR: [RenderColumnScalarWhereInput!]
  NOT: [RenderColumnScalarWhereInput!]
}

type RenderColumnSubscriptionPayload {
  mutation: MutationType!
  node: RenderColumn
  updatedFields: [String!]
  previousValues: RenderColumnPreviousValues
}

input RenderColumnSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RenderColumnWhereInput
  AND: [RenderColumnSubscriptionWhereInput!]
  OR: [RenderColumnSubscriptionWhereInput!]
  NOT: [RenderColumnSubscriptionWhereInput!]
}

input RenderColumnUpdateDataInput {
  widgets: WidgetUpdateManyInput
  width: Int
}

input RenderColumnUpdateInput {
  widgets: WidgetUpdateManyInput
  width: Int
}

input RenderColumnUpdateManyDataInput {
  width: Int
}

input RenderColumnUpdateManyInput {
  create: [RenderColumnCreateInput!]
  update: [RenderColumnUpdateWithWhereUniqueNestedInput!]
  upsert: [RenderColumnUpsertWithWhereUniqueNestedInput!]
  delete: [RenderColumnWhereUniqueInput!]
  connect: [RenderColumnWhereUniqueInput!]
  set: [RenderColumnWhereUniqueInput!]
  disconnect: [RenderColumnWhereUniqueInput!]
  deleteMany: [RenderColumnScalarWhereInput!]
  updateMany: [RenderColumnUpdateManyWithWhereNestedInput!]
}

input RenderColumnUpdateManyMutationInput {
  width: Int
}

input RenderColumnUpdateManyWithWhereNestedInput {
  where: RenderColumnScalarWhereInput!
  data: RenderColumnUpdateManyDataInput!
}

input RenderColumnUpdateWithWhereUniqueNestedInput {
  where: RenderColumnWhereUniqueInput!
  data: RenderColumnUpdateDataInput!
}

input RenderColumnUpsertWithWhereUniqueNestedInput {
  where: RenderColumnWhereUniqueInput!
  update: RenderColumnUpdateDataInput!
  create: RenderColumnCreateInput!
}

input RenderColumnWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  widgets_every: WidgetWhereInput
  widgets_some: WidgetWhereInput
  widgets_none: WidgetWhereInput
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RenderColumnWhereInput!]
  OR: [RenderColumnWhereInput!]
  NOT: [RenderColumnWhereInput!]
}

input RenderColumnWhereUniqueInput {
  id: ID
}

type SMTransition {
  createdAt: DateTime!
  event: String!
  from: String!
  id: ID!
  stateMachineSchema: StateMachineSchema
  to: String!
  updatedAt: DateTime!
}

type SMTransitionConnection {
  pageInfo: PageInfo!
  edges: [SMTransitionEdge]!
  aggregate: AggregateSMTransition!
}

input SMTransitionCreateInput {
  event: String!
  from: String!
  id: ID
  stateMachineSchema: StateMachineSchemaCreateOneWithoutSMTransitionsInput
  to: String!
}

input SMTransitionCreateManyWithoutStateMachineSchemaInput {
  create: [SMTransitionCreateWithoutStateMachineSchemaInput!]
  connect: [SMTransitionWhereUniqueInput!]
}

input SMTransitionCreateWithoutStateMachineSchemaInput {
  event: String!
  from: String!
  id: ID
  to: String!
}

type SMTransitionEdge {
  node: SMTransition!
  cursor: String!
}

enum SMTransitionOrderByInput {
  createdAt_ASC
  createdAt_DESC
  event_ASC
  event_DESC
  from_ASC
  from_DESC
  id_ASC
  id_DESC
  to_ASC
  to_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SMTransitionPreviousValues {
  createdAt: DateTime!
  event: String!
  from: String!
  id: ID!
  to: String!
  updatedAt: DateTime!
}

input SMTransitionScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  event: String
  event_not: String
  event_in: [String!]
  event_not_in: [String!]
  event_lt: String
  event_lte: String
  event_gt: String
  event_gte: String
  event_contains: String
  event_not_contains: String
  event_starts_with: String
  event_not_starts_with: String
  event_ends_with: String
  event_not_ends_with: String
  from: String
  from_not: String
  from_in: [String!]
  from_not_in: [String!]
  from_lt: String
  from_lte: String
  from_gt: String
  from_gte: String
  from_contains: String
  from_not_contains: String
  from_starts_with: String
  from_not_starts_with: String
  from_ends_with: String
  from_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  to: String
  to_not: String
  to_in: [String!]
  to_not_in: [String!]
  to_lt: String
  to_lte: String
  to_gt: String
  to_gte: String
  to_contains: String
  to_not_contains: String
  to_starts_with: String
  to_not_starts_with: String
  to_ends_with: String
  to_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SMTransitionScalarWhereInput!]
  OR: [SMTransitionScalarWhereInput!]
  NOT: [SMTransitionScalarWhereInput!]
}

type SMTransitionSubscriptionPayload {
  mutation: MutationType!
  node: SMTransition
  updatedFields: [String!]
  previousValues: SMTransitionPreviousValues
}

input SMTransitionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SMTransitionWhereInput
  AND: [SMTransitionSubscriptionWhereInput!]
  OR: [SMTransitionSubscriptionWhereInput!]
  NOT: [SMTransitionSubscriptionWhereInput!]
}

input SMTransitionUpdateInput {
  event: String
  from: String
  stateMachineSchema: StateMachineSchemaUpdateOneWithoutSMTransitionsInput
  to: String
}

input SMTransitionUpdateManyDataInput {
  event: String
  from: String
  to: String
}

input SMTransitionUpdateManyMutationInput {
  event: String
  from: String
  to: String
}

input SMTransitionUpdateManyWithoutStateMachineSchemaInput {
  create: [SMTransitionCreateWithoutStateMachineSchemaInput!]
  delete: [SMTransitionWhereUniqueInput!]
  connect: [SMTransitionWhereUniqueInput!]
  set: [SMTransitionWhereUniqueInput!]
  disconnect: [SMTransitionWhereUniqueInput!]
  update: [SMTransitionUpdateWithWhereUniqueWithoutStateMachineSchemaInput!]
  upsert: [SMTransitionUpsertWithWhereUniqueWithoutStateMachineSchemaInput!]
  deleteMany: [SMTransitionScalarWhereInput!]
  updateMany: [SMTransitionUpdateManyWithWhereNestedInput!]
}

input SMTransitionUpdateManyWithWhereNestedInput {
  where: SMTransitionScalarWhereInput!
  data: SMTransitionUpdateManyDataInput!
}

input SMTransitionUpdateWithoutStateMachineSchemaDataInput {
  event: String
  from: String
  to: String
}

input SMTransitionUpdateWithWhereUniqueWithoutStateMachineSchemaInput {
  where: SMTransitionWhereUniqueInput!
  data: SMTransitionUpdateWithoutStateMachineSchemaDataInput!
}

input SMTransitionUpsertWithWhereUniqueWithoutStateMachineSchemaInput {
  where: SMTransitionWhereUniqueInput!
  update: SMTransitionUpdateWithoutStateMachineSchemaDataInput!
  create: SMTransitionCreateWithoutStateMachineSchemaInput!
}

input SMTransitionWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  event: String
  event_not: String
  event_in: [String!]
  event_not_in: [String!]
  event_lt: String
  event_lte: String
  event_gt: String
  event_gte: String
  event_contains: String
  event_not_contains: String
  event_starts_with: String
  event_not_starts_with: String
  event_ends_with: String
  event_not_ends_with: String
  from: String
  from_not: String
  from_in: [String!]
  from_not_in: [String!]
  from_lt: String
  from_lte: String
  from_gt: String
  from_gte: String
  from_contains: String
  from_not_contains: String
  from_starts_with: String
  from_not_starts_with: String
  from_ends_with: String
  from_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stateMachineSchema: StateMachineSchemaWhereInput
  to: String
  to_not: String
  to_in: [String!]
  to_not_in: [String!]
  to_lt: String
  to_lte: String
  to_gt: String
  to_gte: String
  to_contains: String
  to_not_contains: String
  to_starts_with: String
  to_not_starts_with: String
  to_ends_with: String
  to_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SMTransitionWhereInput!]
  OR: [SMTransitionWhereInput!]
  NOT: [SMTransitionWhereInput!]
}

input SMTransitionWhereUniqueInput {
  id: ID
}

type StateMachineSchema {
  createdAt: DateTime!
  finalState: String!
  id: ID!
  initialState: String!
  name: String!
  sMTransitions(where: SMTransitionWhereInput, orderBy: SMTransitionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SMTransition!]
  updatedAt: DateTime!
}

type StateMachineSchemaConnection {
  pageInfo: PageInfo!
  edges: [StateMachineSchemaEdge]!
  aggregate: AggregateStateMachineSchema!
}

input StateMachineSchemaCreateInput {
  finalState: String!
  id: ID
  initialState: String!
  name: String!
  sMTransitions: SMTransitionCreateManyWithoutStateMachineSchemaInput
}

input StateMachineSchemaCreateOneWithoutSMTransitionsInput {
  create: StateMachineSchemaCreateWithoutSMTransitionsInput
  connect: StateMachineSchemaWhereUniqueInput
}

input StateMachineSchemaCreateWithoutSMTransitionsInput {
  finalState: String!
  id: ID
  initialState: String!
  name: String!
}

type StateMachineSchemaEdge {
  node: StateMachineSchema!
  cursor: String!
}

enum StateMachineSchemaOrderByInput {
  createdAt_ASC
  createdAt_DESC
  finalState_ASC
  finalState_DESC
  id_ASC
  id_DESC
  initialState_ASC
  initialState_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StateMachineSchemaPreviousValues {
  createdAt: DateTime!
  finalState: String!
  id: ID!
  initialState: String!
  name: String!
  updatedAt: DateTime!
}

type StateMachineSchemaSubscriptionPayload {
  mutation: MutationType!
  node: StateMachineSchema
  updatedFields: [String!]
  previousValues: StateMachineSchemaPreviousValues
}

input StateMachineSchemaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StateMachineSchemaWhereInput
  AND: [StateMachineSchemaSubscriptionWhereInput!]
  OR: [StateMachineSchemaSubscriptionWhereInput!]
  NOT: [StateMachineSchemaSubscriptionWhereInput!]
}

input StateMachineSchemaUpdateInput {
  finalState: String
  initialState: String
  name: String
  sMTransitions: SMTransitionUpdateManyWithoutStateMachineSchemaInput
}

input StateMachineSchemaUpdateManyMutationInput {
  finalState: String
  initialState: String
  name: String
}

input StateMachineSchemaUpdateOneWithoutSMTransitionsInput {
  create: StateMachineSchemaCreateWithoutSMTransitionsInput
  update: StateMachineSchemaUpdateWithoutSMTransitionsDataInput
  upsert: StateMachineSchemaUpsertWithoutSMTransitionsInput
  delete: Boolean
  disconnect: Boolean
  connect: StateMachineSchemaWhereUniqueInput
}

input StateMachineSchemaUpdateWithoutSMTransitionsDataInput {
  finalState: String
  initialState: String
  name: String
}

input StateMachineSchemaUpsertWithoutSMTransitionsInput {
  update: StateMachineSchemaUpdateWithoutSMTransitionsDataInput!
  create: StateMachineSchemaCreateWithoutSMTransitionsInput!
}

input StateMachineSchemaWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  finalState: String
  finalState_not: String
  finalState_in: [String!]
  finalState_not_in: [String!]
  finalState_lt: String
  finalState_lte: String
  finalState_gt: String
  finalState_gte: String
  finalState_contains: String
  finalState_not_contains: String
  finalState_starts_with: String
  finalState_not_starts_with: String
  finalState_ends_with: String
  finalState_not_ends_with: String
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  initialState: String
  initialState_not: String
  initialState_in: [String!]
  initialState_not_in: [String!]
  initialState_lt: String
  initialState_lte: String
  initialState_gt: String
  initialState_gte: String
  initialState_contains: String
  initialState_not_contains: String
  initialState_starts_with: String
  initialState_not_starts_with: String
  initialState_ends_with: String
  initialState_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  sMTransitions_every: SMTransitionWhereInput
  sMTransitions_some: SMTransitionWhereInput
  sMTransitions_none: SMTransitionWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StateMachineSchemaWhereInput!]
  OR: [StateMachineSchemaWhereInput!]
  NOT: [StateMachineSchemaWhereInput!]
}

input StateMachineSchemaWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  bizAttribute(where: BizAttributeSubscriptionWhereInput): BizAttributeSubscriptionPayload
  bizRelation(where: BizRelationSubscriptionWhereInput): BizRelationSubscriptionPayload
  businessObject(where: BusinessObjectSubscriptionWhereInput): BusinessObjectSubscriptionPayload
  diagram(where: DiagramSubscriptionWhereInput): DiagramSubscriptionPayload
  metaAttribute(where: MetaAttributeSubscriptionWhereInput): MetaAttributeSubscriptionPayload
  metaObject(where: MetaObjectSubscriptionWhereInput): MetaObjectSubscriptionPayload
  metaRelation(where: MetaRelationSubscriptionWhereInput): MetaRelationSubscriptionPayload
  plan(where: PlanSubscriptionWhereInput): PlanSubscriptionPayload
  planConfig(where: PlanConfigSubscriptionWhereInput): PlanConfigSubscriptionPayload
  renderColumn(where: RenderColumnSubscriptionWhereInput): RenderColumnSubscriptionPayload
  sMTransition(where: SMTransitionSubscriptionWhereInput): SMTransitionSubscriptionPayload
  stateMachineSchema(where: StateMachineSchemaSubscriptionWhereInput): StateMachineSchemaSubscriptionPayload
  systemSetup(where: SystemSetupSubscriptionWhereInput): SystemSetupSubscriptionPayload
  template(where: TemplateSubscriptionWhereInput): TemplateSubscriptionPayload
  templateConfig(where: TemplateConfigSubscriptionWhereInput): TemplateConfigSubscriptionPayload
  templateMapping(where: TemplateMappingSubscriptionWhereInput): TemplateMappingSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  widget(where: WidgetSubscriptionWhereInput): WidgetSubscriptionPayload
}

type SystemSetup {
  id: ID!
  systemUserMOMapping: MetaObject
  systemUseridMAMapping: MetaAttribute
  templateConfig: TemplateConfig
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SystemSetupConnection {
  pageInfo: PageInfo!
  edges: [SystemSetupEdge]!
  aggregate: AggregateSystemSetup!
}

input SystemSetupCreateInput {
  id: ID
  systemUserMOMapping: MetaObjectCreateOneInput
  systemUseridMAMapping: MetaAttributeCreateOneInput
  templateConfig: TemplateConfigCreateOneInput
}

type SystemSetupEdge {
  node: SystemSetup!
  cursor: String!
}

enum SystemSetupOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SystemSetupPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SystemSetupSubscriptionPayload {
  mutation: MutationType!
  node: SystemSetup
  updatedFields: [String!]
  previousValues: SystemSetupPreviousValues
}

input SystemSetupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SystemSetupWhereInput
  AND: [SystemSetupSubscriptionWhereInput!]
  OR: [SystemSetupSubscriptionWhereInput!]
  NOT: [SystemSetupSubscriptionWhereInput!]
}

input SystemSetupUpdateInput {
  systemUserMOMapping: MetaObjectUpdateOneInput
  systemUseridMAMapping: MetaAttributeUpdateOneInput
  templateConfig: TemplateConfigUpdateOneInput
}

input SystemSetupWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  systemUserMOMapping: MetaObjectWhereInput
  systemUseridMAMapping: MetaAttributeWhereInput
  templateConfig: TemplateConfigWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SystemSetupWhereInput!]
  OR: [SystemSetupWhereInput!]
  NOT: [SystemSetupWhereInput!]
}

input SystemSetupWhereUniqueInput {
  id: ID
}

type Template {
  id: ID!
  name: String!
  renderColumns(where: RenderColumnWhereInput, orderBy: RenderColumnOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RenderColumn!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateConfig {
  id: ID!
  moObject: MetaObject
  moRelation: MetaRelation
  userRelatedMRId: String
  defaultTemplate: Template
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateConfigConnection {
  pageInfo: PageInfo!
  edges: [TemplateConfigEdge]!
  aggregate: AggregateTemplateConfig!
}

input TemplateConfigCreateInput {
  id: ID
  moObject: MetaObjectCreateOneWithoutTemplateConfigInput
  moRelation: MetaRelationCreateOneInput
  userRelatedMRId: String
  defaultTemplate: TemplateCreateOneInput
}

input TemplateConfigCreateOneInput {
  create: TemplateConfigCreateInput
  connect: TemplateConfigWhereUniqueInput
}

input TemplateConfigCreateOneWithoutMoObjectInput {
  create: TemplateConfigCreateWithoutMoObjectInput
  connect: TemplateConfigWhereUniqueInput
}

input TemplateConfigCreateWithoutMoObjectInput {
  id: ID
  moRelation: MetaRelationCreateOneInput
  userRelatedMRId: String
  defaultTemplate: TemplateCreateOneInput
}

type TemplateConfigEdge {
  node: TemplateConfig!
  cursor: String!
}

enum TemplateConfigOrderByInput {
  id_ASC
  id_DESC
  userRelatedMRId_ASC
  userRelatedMRId_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TemplateConfigPreviousValues {
  id: ID!
  userRelatedMRId: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateConfigSubscriptionPayload {
  mutation: MutationType!
  node: TemplateConfig
  updatedFields: [String!]
  previousValues: TemplateConfigPreviousValues
}

input TemplateConfigSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemplateConfigWhereInput
  AND: [TemplateConfigSubscriptionWhereInput!]
  OR: [TemplateConfigSubscriptionWhereInput!]
  NOT: [TemplateConfigSubscriptionWhereInput!]
}

input TemplateConfigUpdateDataInput {
  moObject: MetaObjectUpdateOneWithoutTemplateConfigInput
  moRelation: MetaRelationUpdateOneInput
  userRelatedMRId: String
  defaultTemplate: TemplateUpdateOneInput
}

input TemplateConfigUpdateInput {
  moObject: MetaObjectUpdateOneWithoutTemplateConfigInput
  moRelation: MetaRelationUpdateOneInput
  userRelatedMRId: String
  defaultTemplate: TemplateUpdateOneInput
}

input TemplateConfigUpdateManyMutationInput {
  userRelatedMRId: String
}

input TemplateConfigUpdateOneInput {
  create: TemplateConfigCreateInput
  update: TemplateConfigUpdateDataInput
  upsert: TemplateConfigUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TemplateConfigWhereUniqueInput
}

input TemplateConfigUpdateOneWithoutMoObjectInput {
  create: TemplateConfigCreateWithoutMoObjectInput
  update: TemplateConfigUpdateWithoutMoObjectDataInput
  upsert: TemplateConfigUpsertWithoutMoObjectInput
  delete: Boolean
  disconnect: Boolean
  connect: TemplateConfigWhereUniqueInput
}

input TemplateConfigUpdateWithoutMoObjectDataInput {
  moRelation: MetaRelationUpdateOneInput
  userRelatedMRId: String
  defaultTemplate: TemplateUpdateOneInput
}

input TemplateConfigUpsertNestedInput {
  update: TemplateConfigUpdateDataInput!
  create: TemplateConfigCreateInput!
}

input TemplateConfigUpsertWithoutMoObjectInput {
  update: TemplateConfigUpdateWithoutMoObjectDataInput!
  create: TemplateConfigCreateWithoutMoObjectInput!
}

input TemplateConfigWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  moObject: MetaObjectWhereInput
  moRelation: MetaRelationWhereInput
  userRelatedMRId: String
  userRelatedMRId_not: String
  userRelatedMRId_in: [String!]
  userRelatedMRId_not_in: [String!]
  userRelatedMRId_lt: String
  userRelatedMRId_lte: String
  userRelatedMRId_gt: String
  userRelatedMRId_gte: String
  userRelatedMRId_contains: String
  userRelatedMRId_not_contains: String
  userRelatedMRId_starts_with: String
  userRelatedMRId_not_starts_with: String
  userRelatedMRId_ends_with: String
  userRelatedMRId_not_ends_with: String
  defaultTemplate: TemplateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TemplateConfigWhereInput!]
  OR: [TemplateConfigWhereInput!]
  NOT: [TemplateConfigWhereInput!]
}

input TemplateConfigWhereUniqueInput {
  id: ID
}

type TemplateConnection {
  pageInfo: PageInfo!
  edges: [TemplateEdge]!
  aggregate: AggregateTemplate!
}

input TemplateCreateInput {
  id: ID
  name: String
  renderColumns: RenderColumnCreateManyInput
}

input TemplateCreateOneInput {
  create: TemplateCreateInput
  connect: TemplateWhereUniqueInput
}

type TemplateEdge {
  node: Template!
  cursor: String!
}

type TemplateMapping {
  id: ID!
  template: Template
  businessObject: BusinessObject
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateMappingConnection {
  pageInfo: PageInfo!
  edges: [TemplateMappingEdge]!
  aggregate: AggregateTemplateMapping!
}

input TemplateMappingCreateInput {
  id: ID
  template: TemplateCreateOneInput
  businessObject: BusinessObjectCreateOneInput
}

type TemplateMappingEdge {
  node: TemplateMapping!
  cursor: String!
}

enum TemplateMappingOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TemplateMappingPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateMappingSubscriptionPayload {
  mutation: MutationType!
  node: TemplateMapping
  updatedFields: [String!]
  previousValues: TemplateMappingPreviousValues
}

input TemplateMappingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemplateMappingWhereInput
  AND: [TemplateMappingSubscriptionWhereInput!]
  OR: [TemplateMappingSubscriptionWhereInput!]
  NOT: [TemplateMappingSubscriptionWhereInput!]
}

input TemplateMappingUpdateInput {
  template: TemplateUpdateOneInput
  businessObject: BusinessObjectUpdateOneInput
}

input TemplateMappingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  template: TemplateWhereInput
  businessObject: BusinessObjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TemplateMappingWhereInput!]
  OR: [TemplateMappingWhereInput!]
  NOT: [TemplateMappingWhereInput!]
}

input TemplateMappingWhereUniqueInput {
  id: ID
}

enum TemplateOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TemplatePreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TemplateSubscriptionPayload {
  mutation: MutationType!
  node: Template
  updatedFields: [String!]
  previousValues: TemplatePreviousValues
}

input TemplateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TemplateWhereInput
  AND: [TemplateSubscriptionWhereInput!]
  OR: [TemplateSubscriptionWhereInput!]
  NOT: [TemplateSubscriptionWhereInput!]
}

input TemplateUpdateDataInput {
  name: String
  renderColumns: RenderColumnUpdateManyInput
}

input TemplateUpdateInput {
  name: String
  renderColumns: RenderColumnUpdateManyInput
}

input TemplateUpdateManyMutationInput {
  name: String
}

input TemplateUpdateOneInput {
  create: TemplateCreateInput
  update: TemplateUpdateDataInput
  upsert: TemplateUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TemplateWhereUniqueInput
}

input TemplateUpsertNestedInput {
  update: TemplateUpdateDataInput!
  create: TemplateCreateInput!
}

input TemplateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  renderColumns_every: RenderColumnWhereInput
  renderColumns_some: RenderColumnWhereInput
  renderColumns_none: RenderColumnWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TemplateWhereInput!]
  OR: [TemplateWhereInput!]
  NOT: [TemplateWhereInput!]
}

input TemplateWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  userid: String
  password: String
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  userid: String
  password: String
  name: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  userid_ASC
  userid_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  userid: String
  password: String
  name: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  userid: String
  password: String
  name: String
}

input UserUpdateManyMutationInput {
  userid: String
  password: String
  name: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userid: String
  userid_not: String
  userid_in: [String!]
  userid_not_in: [String!]
  userid_lt: String
  userid_lte: String
  userid_gt: String
  userid_gte: String
  userid_contains: String
  userid_not_contains: String
  userid_starts_with: String
  userid_not_starts_with: String
  userid_ends_with: String
  userid_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  userid: String
  name: String
}

type Widget {
  id: ID!
  name: String
  type: WidgetType!
  width: Int
  boid: String
  text: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WidgetConnection {
  pageInfo: PageInfo!
  edges: [WidgetEdge]!
  aggregate: AggregateWidget!
}

input WidgetCreateInput {
  id: ID
  name: String
  type: WidgetType!
  width: Int
  boid: String
  text: String
}

input WidgetCreateManyInput {
  create: [WidgetCreateInput!]
  connect: [WidgetWhereUniqueInput!]
}

type WidgetEdge {
  node: Widget!
  cursor: String!
}

enum WidgetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  width_ASC
  width_DESC
  boid_ASC
  boid_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WidgetPreviousValues {
  id: ID!
  name: String
  type: WidgetType!
  width: Int
  boid: String
  text: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input WidgetScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: WidgetType
  type_not: WidgetType
  type_in: [WidgetType!]
  type_not_in: [WidgetType!]
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  boid: String
  boid_not: String
  boid_in: [String!]
  boid_not_in: [String!]
  boid_lt: String
  boid_lte: String
  boid_gt: String
  boid_gte: String
  boid_contains: String
  boid_not_contains: String
  boid_starts_with: String
  boid_not_starts_with: String
  boid_ends_with: String
  boid_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WidgetScalarWhereInput!]
  OR: [WidgetScalarWhereInput!]
  NOT: [WidgetScalarWhereInput!]
}

type WidgetSubscriptionPayload {
  mutation: MutationType!
  node: Widget
  updatedFields: [String!]
  previousValues: WidgetPreviousValues
}

input WidgetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WidgetWhereInput
  AND: [WidgetSubscriptionWhereInput!]
  OR: [WidgetSubscriptionWhereInput!]
  NOT: [WidgetSubscriptionWhereInput!]
}

enum WidgetType {
  Text
  Plan
  HTML
  Diagram
  Navigation
  Tree
  Video
}

input WidgetUpdateDataInput {
  name: String
  type: WidgetType
  width: Int
  boid: String
  text: String
}

input WidgetUpdateInput {
  name: String
  type: WidgetType
  width: Int
  boid: String
  text: String
}

input WidgetUpdateManyDataInput {
  name: String
  type: WidgetType
  width: Int
  boid: String
  text: String
}

input WidgetUpdateManyInput {
  create: [WidgetCreateInput!]
  update: [WidgetUpdateWithWhereUniqueNestedInput!]
  upsert: [WidgetUpsertWithWhereUniqueNestedInput!]
  delete: [WidgetWhereUniqueInput!]
  connect: [WidgetWhereUniqueInput!]
  set: [WidgetWhereUniqueInput!]
  disconnect: [WidgetWhereUniqueInput!]
  deleteMany: [WidgetScalarWhereInput!]
  updateMany: [WidgetUpdateManyWithWhereNestedInput!]
}

input WidgetUpdateManyMutationInput {
  name: String
  type: WidgetType
  width: Int
  boid: String
  text: String
}

input WidgetUpdateManyWithWhereNestedInput {
  where: WidgetScalarWhereInput!
  data: WidgetUpdateManyDataInput!
}

input WidgetUpdateWithWhereUniqueNestedInput {
  where: WidgetWhereUniqueInput!
  data: WidgetUpdateDataInput!
}

input WidgetUpsertWithWhereUniqueNestedInput {
  where: WidgetWhereUniqueInput!
  update: WidgetUpdateDataInput!
  create: WidgetCreateInput!
}

input WidgetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: WidgetType
  type_not: WidgetType
  type_in: [WidgetType!]
  type_not_in: [WidgetType!]
  width: Int
  width_not: Int
  width_in: [Int!]
  width_not_in: [Int!]
  width_lt: Int
  width_lte: Int
  width_gt: Int
  width_gte: Int
  boid: String
  boid_not: String
  boid_in: [String!]
  boid_not_in: [String!]
  boid_lt: String
  boid_lte: String
  boid_gt: String
  boid_gte: String
  boid_contains: String
  boid_not_contains: String
  boid_starts_with: String
  boid_not_starts_with: String
  boid_ends_with: String
  boid_not_ends_with: String
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WidgetWhereInput!]
  OR: [WidgetWhereInput!]
  NOT: [WidgetWhereInput!]
}

input WidgetWhereUniqueInput {
  id: ID
}
`